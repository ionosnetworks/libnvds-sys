/* automatically generated by rust-bindgen 0.69.1 */

pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gsize = ::std::os::raw::c_ulong;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type GQuark = guint32;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GMutex() {
    const UNINIT: ::std::mem::MaybeUninit<_GMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMutex>(),
        8usize,
        concat!("Size of: ", stringify!(_GMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRecMutex() {
    const UNINIT: ::std::mem::MaybeUninit<_GRecMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GRecMutex>(),
        16usize,
        concat!("Size of: ", stringify!(_GRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRecMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    const UNINIT: ::std::mem::MaybeUninit<_GList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
pub type GType = gsize;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
pub type GTypeClass = _GTypeClass;
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
pub type GTypeInstance = _GTypeInstance;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeClass>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeClass),
            "::",
            stringify!(g_type)
        )
    );
}
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[test]
fn bindgen_test_layout__GTypeInstance() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeInstance> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeInstance>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInstance),
            "::",
            stringify!(g_class)
        )
    );
}
#[doc = " GObject:\n\n All the fields in the GObject structure are private\n to the #GObject implementation and should never be accessed directly."]
pub type GInitiallyUnowned = _GObject;
#[doc = " GObject:\n\n All the fields in the GObject structure are private\n to the #GObject implementation and should never be accessed directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[test]
fn bindgen_test_layout__GObject() {
    const UNINIT: ::std::mem::MaybeUninit<_GObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GObject>(),
        24usize,
        concat!("Size of: ", stringify!(_GObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qdata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(qdata)
        )
    );
}
#[doc = " GstObject:\n @lock: object LOCK\n @name: The name of the object\n @parent: this object's parent, weak ref\n @flags: flags for this object\n\n GStreamer base object class."]
pub type GstObject = _GstObject;
#[doc = " GstObject:\n @lock: object LOCK\n @name: The name of the object\n @parent: this object's parent, weak ref\n @flags: flags for this object\n\n GStreamer base object class."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstObject {
    pub object: GInitiallyUnowned,
    pub lock: GMutex,
    pub name: *mut gchar,
    pub parent: *mut GstObject,
    pub flags: guint32,
    pub control_bindings: *mut GList,
    pub control_rate: guint64,
    pub last_sync: guint64,
    pub _gst_reserved: gpointer,
}
#[test]
fn bindgen_test_layout__GstObject() {
    const UNINIT: ::std::mem::MaybeUninit<_GstObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GstObject>(),
        88usize,
        concat!("Size of: ", stringify!(_GstObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GstObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GstObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_bindings) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(control_bindings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_rate) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(control_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_sync) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(last_sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._gst_reserved) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(_gst_reserved)
        )
    );
}
#[doc = " GstClockTime:\n\n A datatype to hold a time, measured in nanoseconds."]
pub type GstClockTime = guint64;
#[doc = " GstMiniObject: (ref-func gst_mini_object_ref) (unref-func gst_mini_object_unref) (set-value-func g_value_set_boxed) (get-value-func g_value_get_boxed)\n @type: the GType of the object\n @refcount: atomic refcount\n @lockstate: atomic state of the locks\n @flags: extra flags.\n @copy: a copy function\n @dispose: a dispose function\n @free: the free function\n\n Base class for refcounted lightweight objects."]
pub type GstMiniObject = _GstMiniObject;
#[doc = " GstMiniObjectCopyFunction:\n @obj: MiniObject to copy\n\n Function prototype for methods to create copies of instances.\n\n Returns: reference to cloned instance."]
pub type GstMiniObjectCopyFunction =
    ::std::option::Option<unsafe extern "C" fn(obj: *const GstMiniObject) -> *mut GstMiniObject>;
#[doc = " GstMiniObjectDisposeFunction:\n @obj: MiniObject to dispose\n\n Function prototype for when a miniobject has lost its last refcount.\n Implementation of the mini object are allowed to revive the\n passed object by doing a gst_mini_object_ref(). If the object is not\n revived after the dispose function, the function should return %TRUE\n and the memory associated with the object is freed.\n\n Returns: %TRUE if the object should be cleaned up."]
pub type GstMiniObjectDisposeFunction =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut GstMiniObject) -> gboolean>;
#[doc = " GstMiniObjectFreeFunction:\n @obj: MiniObject to free\n\n Virtual function prototype for methods to free resources used by\n mini-objects."]
pub type GstMiniObjectFreeFunction =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut GstMiniObject)>;
#[doc = " GstMiniObject: (ref-func gst_mini_object_ref) (unref-func gst_mini_object_unref) (set-value-func g_value_set_boxed) (get-value-func g_value_get_boxed)\n @type: the GType of the object\n @refcount: atomic refcount\n @lockstate: atomic state of the locks\n @flags: extra flags.\n @copy: a copy function\n @dispose: a dispose function\n @free: the free function\n\n Base class for refcounted lightweight objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstMiniObject {
    pub type_: GType,
    pub refcount: gint,
    pub lockstate: gint,
    pub flags: guint,
    pub copy: GstMiniObjectCopyFunction,
    pub dispose: GstMiniObjectDisposeFunction,
    pub free: GstMiniObjectFreeFunction,
    pub priv_uint: guint,
    pub priv_pointer: gpointer,
}
#[test]
fn bindgen_test_layout__GstMiniObject() {
    const UNINIT: ::std::mem::MaybeUninit<_GstMiniObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GstMiniObject>(),
        64usize,
        concat!("Size of: ", stringify!(_GstMiniObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GstMiniObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GstMiniObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lockstate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(lockstate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispose) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(dispose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_uint) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(priv_uint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_pointer) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(priv_pointer)
        )
    );
}
#[doc = " GstBuffer:\n @mini_object: the parent structure\n @pool: pointer to the pool owner of the buffer\n @pts: presentation timestamp of the buffer, can be #GST_CLOCK_TIME_NONE when the\n     pts is not known or relevant. The pts contains the timestamp when the\n     media should be presented to the user.\n @dts: decoding timestamp of the buffer, can be #GST_CLOCK_TIME_NONE when the\n     dts is not known or relevant. The dts contains the timestamp when the\n     media should be processed.\n @duration: duration in time of the buffer data, can be #GST_CLOCK_TIME_NONE\n     when the duration is not known or relevant.\n @offset: a media specific offset for the buffer data.\n     For video frames, this is the frame number of this buffer.\n     For audio samples, this is the offset of the first sample in this buffer.\n     For file data or compressed data this is the byte offset of the first\n       byte in this buffer.\n @offset_end: the last offset contained in this buffer. It has the same\n     format as @offset.\n\n The structure of a #GstBuffer. Use the associated macros to access the public\n variables."]
pub type GstBuffer = _GstBuffer;
#[doc = " GstBufferPool:\n\n The structure of a #GstBufferPool. Use the associated macros to access the public\n variables."]
pub type GstBufferPool = _GstBufferPool;
#[doc = " GstMeta:\n @flags: extra flags for the metadata\n @info: pointer to the #GstMetaInfo\n\n Base structure for metadata. Custom metadata will put this structure\n as the first member of their structure."]
pub type GstMeta = _GstMeta;
#[doc = " GstMetaInfo:\n @api: tag identifying the metadata structure and api\n @type: type identifying the implementor of the api\n @size: size of the metadata\n @init_func: function for initializing the metadata\n @free_func: function for freeing the metadata\n @transform_func: function for transforming the metadata\n\n The #GstMetaInfo provides information about a specific metadata\n structure."]
pub type GstMetaInfo = _GstMetaInfo;
pub const GstMetaFlags_GST_META_FLAG_NONE: GstMetaFlags = 0;
pub const GstMetaFlags_GST_META_FLAG_READONLY: GstMetaFlags = 1;
pub const GstMetaFlags_GST_META_FLAG_POOLED: GstMetaFlags = 2;
pub const GstMetaFlags_GST_META_FLAG_LOCKED: GstMetaFlags = 4;
pub const GstMetaFlags_GST_META_FLAG_LAST: GstMetaFlags = 65536;
#[doc = " GstMetaFlags:\n @GST_META_FLAG_NONE: no flags\n @GST_META_FLAG_READONLY: metadata should not be modified\n @GST_META_FLAG_POOLED: metadata is managed by a bufferpool\n @GST_META_FLAG_LOCKED: metadata should not be removed\n @GST_META_FLAG_LAST: additional flags can be added starting from this flag.\n\n Extra metadata flags."]
pub type GstMetaFlags = ::std::os::raw::c_uint;
#[doc = " GstMeta:\n @flags: extra flags for the metadata\n @info: pointer to the #GstMetaInfo\n\n Base structure for metadata. Custom metadata will put this structure\n as the first member of their structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstMeta {
    pub flags: GstMetaFlags,
    pub info: *const GstMetaInfo,
}
#[test]
fn bindgen_test_layout__GstMeta() {
    const UNINIT: ::std::mem::MaybeUninit<_GstMeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GstMeta>(),
        16usize,
        concat!("Size of: ", stringify!(_GstMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_GstMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_GstMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMeta),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMeta),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " GstMetaInitFunction:\n @meta: a #GstMeta\n @params: parameters passed to the init function\n @buffer: a #GstBuffer\n\n Function called when @meta is initialized in @buffer."]
pub type GstMetaInitFunction = ::std::option::Option<
    unsafe extern "C" fn(meta: *mut GstMeta, params: gpointer, buffer: *mut GstBuffer) -> gboolean,
>;
#[doc = " GstMetaFreeFunction:\n @meta: a #GstMeta\n @buffer: a #GstBuffer\n\n Function called when @meta is freed in @buffer."]
pub type GstMetaFreeFunction =
    ::std::option::Option<unsafe extern "C" fn(meta: *mut GstMeta, buffer: *mut GstBuffer)>;
#[doc = " GstMetaTransformFunction:\n @transbuf: a #GstBuffer\n @meta: a #GstMeta\n @buffer: a #GstBuffer\n @type: the transform type\n @data: transform specific data.\n\n Function called for each @meta in @buffer as a result of performing a\n transformation on @transbuf. Additional @type specific transform data\n is passed to the function as @data.\n\n Implementations should check the @type of the transform and parse\n additional type specific fields in @data that should be used to update\n the metadata on @transbuf.\n\n Returns: %TRUE if the transform could be performed"]
pub type GstMetaTransformFunction = ::std::option::Option<
    unsafe extern "C" fn(
        transbuf: *mut GstBuffer,
        meta: *mut GstMeta,
        buffer: *mut GstBuffer,
        type_: GQuark,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GstMetaInfo:\n @api: tag identifying the metadata structure and api\n @type: type identifying the implementor of the api\n @size: size of the metadata\n @init_func: function for initializing the metadata\n @free_func: function for freeing the metadata\n @transform_func: function for transforming the metadata\n\n The #GstMetaInfo provides information about a specific metadata\n structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstMetaInfo {
    pub api: GType,
    pub type_: GType,
    pub size: gsize,
    pub init_func: GstMetaInitFunction,
    pub free_func: GstMetaFreeFunction,
    pub transform_func: GstMetaTransformFunction,
}
#[test]
fn bindgen_test_layout__GstMetaInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GstMetaInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GstMetaInfo>(),
        48usize,
        concat!("Size of: ", stringify!(_GstMetaInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GstMetaInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GstMetaInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).api) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMetaInfo),
            "::",
            stringify!(api)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMetaInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMetaInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMetaInfo),
            "::",
            stringify!(init_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMetaInfo),
            "::",
            stringify!(free_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMetaInfo),
            "::",
            stringify!(transform_func)
        )
    );
}
#[doc = " GstBuffer:\n @mini_object: the parent structure\n @pool: pointer to the pool owner of the buffer\n @pts: presentation timestamp of the buffer, can be #GST_CLOCK_TIME_NONE when the\n     pts is not known or relevant. The pts contains the timestamp when the\n     media should be presented to the user.\n @dts: decoding timestamp of the buffer, can be #GST_CLOCK_TIME_NONE when the\n     dts is not known or relevant. The dts contains the timestamp when the\n     media should be processed.\n @duration: duration in time of the buffer data, can be #GST_CLOCK_TIME_NONE\n     when the duration is not known or relevant.\n @offset: a media specific offset for the buffer data.\n     For video frames, this is the frame number of this buffer.\n     For audio samples, this is the offset of the first sample in this buffer.\n     For file data or compressed data this is the byte offset of the first\n       byte in this buffer.\n @offset_end: the last offset contained in this buffer. It has the same\n     format as @offset.\n\n The structure of a #GstBuffer. Use the associated macros to access the public\n variables."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBuffer {
    pub mini_object: GstMiniObject,
    pub pool: *mut GstBufferPool,
    pub pts: GstClockTime,
    pub dts: GstClockTime,
    pub duration: GstClockTime,
    pub offset: guint64,
    pub offset_end: guint64,
}
#[test]
fn bindgen_test_layout__GstBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<_GstBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GstBuffer>(),
        112usize,
        concat!("Size of: ", stringify!(_GstBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_GstBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_GstBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mini_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(mini_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dts) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_end) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(offset_end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBufferPoolPrivate {
    _unused: [u8; 0],
}
pub type GstBufferPoolPrivate = _GstBufferPoolPrivate;
#[doc = " GstBufferPool:\n\n The structure of a #GstBufferPool. Use the associated macros to access the public\n variables."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstBufferPool {
    pub object: GstObject,
    pub flushing: gint,
    pub priv_: *mut GstBufferPoolPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GstBufferPool() {
    const UNINIT: ::std::mem::MaybeUninit<_GstBufferPool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GstBufferPool>(),
        136usize,
        concat!("Size of: ", stringify!(_GstBufferPool))
    );
    assert_eq!(
        ::std::mem::align_of::<_GstBufferPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_GstBufferPool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBufferPool),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushing) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBufferPool),
            "::",
            stringify!(flushing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBufferPool),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._gst_reserved) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBufferPool),
            "::",
            stringify!(_gst_reserved)
        )
    );
}
#[doc = " Specifies an arrow head only at start = 0."]
pub const NvOSD_Arrow_Head_Direction_START_HEAD: NvOSD_Arrow_Head_Direction = 0;
#[doc = " Specifies an arrow head only at end = 1."]
pub const NvOSD_Arrow_Head_Direction_END_HEAD: NvOSD_Arrow_Head_Direction = 1;
#[doc = " Specifies arrow heads at both start and end = 2."]
pub const NvOSD_Arrow_Head_Direction_BOTH_HEAD: NvOSD_Arrow_Head_Direction = 2;
#[doc = " Specifies arrow head positions."]
pub type NvOSD_Arrow_Head_Direction = ::std::os::raw::c_uint;
#[doc = " Holds unclipped bounding box coordinates of the object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvBbox_Coords {
    #[doc = "< Holds the box's left coordinate\nin pixels."]
    pub left: f32,
    #[doc = "< Holds the box's top coordinate\nin pixels."]
    pub top: f32,
    #[doc = "< Holds the box's width in pixels."]
    pub width: f32,
    #[doc = "< Holds the box's height in pixels."]
    pub height: f32,
}
#[test]
fn bindgen_test_layout__NvBbox_Coords() {
    const UNINIT: ::std::mem::MaybeUninit<_NvBbox_Coords> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvBbox_Coords>(),
        16usize,
        concat!("Size of: ", stringify!(_NvBbox_Coords))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvBbox_Coords>(),
        4usize,
        concat!("Alignment of ", stringify!(_NvBbox_Coords))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvBbox_Coords),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvBbox_Coords),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvBbox_Coords),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvBbox_Coords),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Holds unclipped bounding box coordinates of the object."]
pub type NvBbox_Coords = _NvBbox_Coords;
#[doc = " Holds the color parameters of the box or text to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_ColorParams {
    #[doc = "< Holds the red component of color.\nValue must be in the range 0.0-1.0."]
    pub red: f64,
    #[doc = "< Holds the green component of color.\nValue must be in the range 0.0-1.0."]
    pub green: f64,
    #[doc = "< Holds the blue component of color.\nValue must be in the range 0.0-1.0."]
    pub blue: f64,
    #[doc = "< Holds the alpha component of color.\nValue must be in the range 0.0-1.0."]
    pub alpha: f64,
}
#[test]
fn bindgen_test_layout__NvOSD_ColorParams() {
    const UNINIT: ::std::mem::MaybeUninit<_NvOSD_ColorParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_ColorParams>(),
        32usize,
        concat!("Size of: ", stringify!(_NvOSD_ColorParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_ColorParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_ColorParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ColorParams),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ColorParams),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ColorParams),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ColorParams),
            "::",
            stringify!(alpha)
        )
    );
}
#[doc = " Holds the color parameters of the box or text to be overlayed."]
pub type NvOSD_ColorParams = _NvOSD_ColorParams;
#[doc = " Holds the font parameters of the text to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_FontParams {
    #[doc = "< Holds a pointer to the string containing\nthe font name. To display a list of\nsupported fonts, run the fc-list command."]
    pub font_name: *mut ::std::os::raw::c_char,
    #[doc = "< Holds the size of the font."]
    pub font_size: ::std::os::raw::c_uint,
    #[doc = "< Holds the font color."]
    pub font_color: NvOSD_ColorParams,
}
#[test]
fn bindgen_test_layout__NvOSD_FontParams() {
    const UNINIT: ::std::mem::MaybeUninit<_NvOSD_FontParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_FontParams>(),
        48usize,
        concat!("Size of: ", stringify!(_NvOSD_FontParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_FontParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_FontParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_FontParams),
            "::",
            stringify!(font_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_FontParams),
            "::",
            stringify!(font_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_color) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_FontParams),
            "::",
            stringify!(font_color)
        )
    );
}
#[doc = " Holds the font parameters of the text to be overlayed."]
pub type NvOSD_FontParams = _NvOSD_FontParams;
#[doc = " Holds parameters of text to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_TextParams {
    #[doc = "< Holds the text to be overlayed."]
    pub display_text: *mut ::std::os::raw::c_char,
    #[doc = "< Holds the text's horizontal offset from\nthe top left pixel of the frame."]
    pub x_offset: ::std::os::raw::c_uint,
    #[doc = "< Holds the text's vertical offset from the\ntop left pixel of the frame."]
    pub y_offset: ::std::os::raw::c_uint,
    #[doc = "< Holds the font parameters of the text\nto be overlaid."]
    pub font_params: NvOSD_FontParams,
    #[doc = "< Holds a Boolean; true if the text has a\nbackground color."]
    pub set_bg_clr: ::std::os::raw::c_int,
    #[doc = "< Holds the text's background color, if\nspecified."]
    pub text_bg_clr: NvOSD_ColorParams,
}
#[test]
fn bindgen_test_layout__NvOSD_TextParams() {
    const UNINIT: ::std::mem::MaybeUninit<_NvOSD_TextParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_TextParams>(),
        104usize,
        concat!("Size of: ", stringify!(_NvOSD_TextParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_TextParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_TextParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_TextParams),
            "::",
            stringify!(display_text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_TextParams),
            "::",
            stringify!(x_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_offset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_TextParams),
            "::",
            stringify!(y_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_params) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_TextParams),
            "::",
            stringify!(font_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_bg_clr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_TextParams),
            "::",
            stringify!(set_bg_clr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_bg_clr) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_TextParams),
            "::",
            stringify!(text_bg_clr)
        )
    );
}
#[doc = " Holds parameters of text to be overlayed."]
pub type NvOSD_TextParams = _NvOSD_TextParams;
#[doc = " Holds the box parameters of the box to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_RectParams {
    #[doc = "< Holds the box's left coordinate\nin pixels."]
    pub left: f32,
    #[doc = "< Holds the box's top coordinate\nin pixels."]
    pub top: f32,
    #[doc = "< Holds the box's width in pixels."]
    pub width: f32,
    #[doc = "< Holds the box's height in pixels."]
    pub height: f32,
    #[doc = "< Holds the box's border width in pixels."]
    pub border_width: ::std::os::raw::c_uint,
    pub border_color: NvOSD_ColorParams,
    #[doc = "< Holds a Boolean; true if the box has a\nbackground color."]
    pub has_bg_color: ::std::os::raw::c_uint,
    #[doc = "< Holds a field reserved for future use."]
    pub reserved: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's background color."]
    pub bg_color: NvOSD_ColorParams,
    pub has_color_info: ::std::os::raw::c_int,
    pub color_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__NvOSD_RectParams() {
    const UNINIT: ::std::mem::MaybeUninit<_NvOSD_RectParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_RectParams>(),
        104usize,
        concat!("Size of: ", stringify!(_NvOSD_RectParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_RectParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_RectParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_color) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(border_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_bg_color) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(has_bg_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bg_color) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(bg_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_color_info) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(has_color_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_id) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(color_id)
        )
    );
}
#[doc = " Holds the box parameters of the box to be overlayed."]
pub type NvOSD_RectParams = _NvOSD_RectParams;
#[doc = " Holds the mask parameters of the segment to be overlayed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_MaskParams {
    pub data: *mut f32,
    #[doc = " Mask data"]
    pub size: ::std::os::raw::c_uint,
    #[doc = " Mask size"]
    pub threshold: f32,
    #[doc = " Threshold for binarization"]
    pub width: ::std::os::raw::c_uint,
    #[doc = " Mask width"]
    pub height: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__NvOSD_MaskParams() {
    const UNINIT: ::std::mem::MaybeUninit<_NvOSD_MaskParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_MaskParams>(),
        24usize,
        concat!("Size of: ", stringify!(_NvOSD_MaskParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_MaskParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_MaskParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_MaskParams),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_MaskParams),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_MaskParams),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_MaskParams),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_MaskParams),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Holds the mask parameters of the segment to be overlayed"]
pub type NvOSD_MaskParams = _NvOSD_MaskParams;
#[doc = " Holds the box parameters of a line to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_LineParams {
    #[doc = "< Holds the box's left coordinate\nin pixels."]
    pub x1: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's top coordinate\nin pixels."]
    pub y1: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's width in pixels."]
    pub x2: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's height in pixels."]
    pub y2: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's border width in pixels."]
    pub line_width: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's border color."]
    pub line_color: NvOSD_ColorParams,
}
#[test]
fn bindgen_test_layout__NvOSD_LineParams() {
    const UNINIT: ::std::mem::MaybeUninit<_NvOSD_LineParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_LineParams>(),
        56usize,
        concat!("Size of: ", stringify!(_NvOSD_LineParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_LineParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_LineParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_LineParams),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_LineParams),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_LineParams),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_LineParams),
            "::",
            stringify!(y2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_LineParams),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_color) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_LineParams),
            "::",
            stringify!(line_color)
        )
    );
}
#[doc = " Holds the box parameters of a line to be overlayed."]
pub type NvOSD_LineParams = _NvOSD_LineParams;
#[doc = " Holds arrow parameters to be overlaid."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_ArrowParams {
    #[doc = "< Holds the start horizontal coordinate in pixels."]
    pub x1: ::std::os::raw::c_uint,
    #[doc = "< Holds the start vertical coordinate in pixels."]
    pub y1: ::std::os::raw::c_uint,
    #[doc = "< Holds the end horizontal coordinate in pixels."]
    pub x2: ::std::os::raw::c_uint,
    #[doc = "< Holds the end vertical coordinate in pixels."]
    pub y2: ::std::os::raw::c_uint,
    #[doc = "< Holds the arrow shaft width in pixels."]
    pub arrow_width: ::std::os::raw::c_uint,
    pub arrow_head: NvOSD_Arrow_Head_Direction,
    pub arrow_color: NvOSD_ColorParams,
    #[doc = "< Reserved for future use; currently\nfor internal use only."]
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__NvOSD_ArrowParams() {
    const UNINIT: ::std::mem::MaybeUninit<_NvOSD_ArrowParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_ArrowParams>(),
        64usize,
        concat!("Size of: ", stringify!(_NvOSD_ArrowParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_ArrowParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_ArrowParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(y2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrow_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(arrow_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrow_head) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(arrow_head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrow_color) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(arrow_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds arrow parameters to be overlaid."]
pub type NvOSD_ArrowParams = _NvOSD_ArrowParams;
#[doc = " Holds circle parameters to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_CircleParams {
    #[doc = "< Holds the start horizontal coordinate in pixels."]
    pub xc: ::std::os::raw::c_uint,
    #[doc = "< Holds the start vertical coordinate in pixels."]
    pub yc: ::std::os::raw::c_uint,
    #[doc = "< Holds the radius of circle in pixels."]
    pub radius: ::std::os::raw::c_uint,
    pub circle_color: NvOSD_ColorParams,
    pub has_bg_color: ::std::os::raw::c_uint,
    pub bg_color: NvOSD_ColorParams,
    #[doc = "< Reserved for future use; currently\nfor internal use only."]
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__NvOSD_CircleParams() {
    const UNINIT: ::std::mem::MaybeUninit<_NvOSD_CircleParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_CircleParams>(),
        96usize,
        concat!("Size of: ", stringify!(_NvOSD_CircleParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_CircleParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_CircleParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(xc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(yc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radius) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(radius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).circle_color) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(circle_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_bg_color) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(has_bg_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bg_color) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(bg_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds circle parameters to be overlayed."]
pub type NvOSD_CircleParams = _NvOSD_CircleParams;
#[doc = " DS NvDsFrameMeta"]
pub type NvDsFrameMeta = _NvDsFrameMeta;
#[doc = " classifier meta list"]
pub type NvDsClassifierMetaList = GList;
#[doc = " user meta list"]
pub type NvDsUserMetaList = GList;
#[doc = " FP32 data type"]
pub const NvDsDataType_NvDsDataType_FP32: NvDsDataType = 0;
#[doc = " UINT8 data type"]
pub const NvDsDataType_NvDsDataType_UINT8: NvDsDataType = 1;
#[doc = " INT8 data type"]
pub const NvDsDataType_NvDsDataType_INT8: NvDsDataType = 2;
#[doc = " UINT32 data type"]
pub const NvDsDataType_NvDsDataType_UINT32: NvDsDataType = 3;
#[doc = " INT32 data type"]
pub const NvDsDataType_NvDsDataType_INT32: NvDsDataType = 4;
#[doc = " FP16 data type"]
pub const NvDsDataType_NvDsDataType_FP16: NvDsDataType = 5;
#[doc = " Data type used for model in infer"]
pub type NvDsDataType = ::std::os::raw::c_uint;
#[doc = " Full frames"]
pub const NvDsUnitType_NvDsUnitType_FullFrame: NvDsUnitType = 0;
#[doc = " Region of Interests (ROIs)"]
pub const NvDsUnitType_NvDsUnitType_ROI: NvDsUnitType = 1;
#[doc = " object mode"]
pub const NvDsUnitType_NvDsUnitType_Object: NvDsUnitType = 2;
#[doc = " Unit Type Fullframe/ROI/Crop Objects"]
pub type NvDsUnitType = ::std::os::raw::c_uint;
#[doc = " Holds Information about ROI Metadata"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsRoiMeta {
    pub roi: NvOSD_RectParams,
    #[doc = " currently not being used"]
    pub roi_polygon: [[guint; 2usize]; 8usize],
    pub converted_buffer: *mut NvBufSurfaceParams,
    pub frame_meta: *mut NvDsFrameMeta,
    #[doc = " Ratio by which the frame/ROI crop was scaled in horizontal direction\n Required when scaling co-ordinates/sizes in metadata\n back to input resolution."]
    pub scale_ratio_x: gdouble,
    #[doc = " Ratio by which the frame/ROI crop was scaled in vertical direction\n Required when scaling co-ordinates/sizes in metadata\n back to input resolution."]
    pub scale_ratio_y: gdouble,
    #[doc = " offsets in horizontal direction while scaling"]
    pub offset_left: gdouble,
    #[doc = " offsets in vertical direction while scaling"]
    pub offset_top: gdouble,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsClassifierMeta."]
    pub classifier_meta_list: *mut NvDsClassifierMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta."]
    pub roi_user_meta_list: *mut NvDsUserMetaList,
}
#[test]
fn bindgen_test_layout_NvDsRoiMeta() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsRoiMeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsRoiMeta>(),
        232usize,
        concat!("Size of: ", stringify!(NvDsRoiMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsRoiMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsRoiMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(roi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roi_polygon) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(roi_polygon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).converted_buffer) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(converted_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_meta) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(frame_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale_ratio_x) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(scale_ratio_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale_ratio_y) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(scale_ratio_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_left) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(offset_left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_top) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(offset_top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classifier_meta_list) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(classifier_meta_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roi_user_meta_list) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(roi_user_meta_list)
        )
    );
}
pub type NvDsFrameMetaList = GList;
pub type NvDsObjectMetaList = GList;
pub type NvDisplayMetaList = GList;
pub type NvDsLabelInfoList = GList;
pub type NvDsMetaList = GList;
pub type NvDsElementMeta = ::std::os::raw::c_void;
#[doc = " \\brief  Defines the type of a callback to copy metadata.\n\n The callback is passed pointers to source metadata. It allocates the\n required memory, copies the content from the source metadata and returns\n a pointer to the destination.\n\n @param[in]  data         A pointer to the source metadata.\n @param[in]  user_data    A pointer to user-specific data."]
pub type NvDsMetaCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
#[doc = " \\brief  Defines the type of a callback to free metadata.\n\n The callback is passed a pointer to metadata created by NvDsMetaCopyFunc().\n It frees the metadata and\n any other resources that the metadata uses.\n\n @param[in]  data         A pointer to the metadata to be freed.\n @param[in]  user_data    A pointer to user-specific data."]
pub type NvDsMetaReleaseFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub const NvDsMetaType_NVDS_INVALID_META: NvDsMetaType = -1;
#[doc = " Specifies metadata type for formed batch."]
pub const NvDsMetaType_NVDS_BATCH_META: NvDsMetaType = 1;
#[doc = " Specifies metadata type for frame."]
pub const NvDsMetaType_NVDS_FRAME_META: NvDsMetaType = 2;
#[doc = " Specifies metadata type for a detected object."]
pub const NvDsMetaType_NVDS_OBJ_META: NvDsMetaType = 3;
#[doc = " Specifies metadata type for display."]
pub const NvDsMetaType_NVDS_DISPLAY_META: NvDsMetaType = 4;
#[doc = " Specifies metadata type for an object classifier."]
pub const NvDsMetaType_NVDS_CLASSIFIER_META: NvDsMetaType = 5;
#[doc = " Specifies metadata type for a label assigned by a classifier."]
pub const NvDsMetaType_NVDS_LABEL_INFO_META: NvDsMetaType = 6;
#[doc = " Reserved for internal use."]
pub const NvDsMetaType_NVDS_USER_META: NvDsMetaType = 7;
#[doc = " Specifies metadata type for a payload generated by a message converter."]
pub const NvDsMetaType_NVDS_PAYLOAD_META: NvDsMetaType = 8;
#[doc = " Specifies metadata type for a payload generated by a message broker."]
pub const NvDsMetaType_NVDS_EVENT_MSG_META: NvDsMetaType = 9;
#[doc = " Specifies metadata type for an optical flow."]
pub const NvDsMetaType_NVDS_OPTICAL_FLOW_META: NvDsMetaType = 10;
#[doc = " Specifies metadata type for a latency measurement."]
pub const NvDsMetaType_NVDS_LATENCY_MEASUREMENT_META: NvDsMetaType = 11;
#[doc = " Specifies metadata type for raw inference output attached by Gst-nvinfer.\n@see NvDsInferTensorMeta for details."]
pub const NvDsMetaType_NVDSINFER_TENSOR_OUTPUT_META: NvDsMetaType = 12;
#[doc = " Specifies metadata type for segmentation model output attached by\nGst-nvinfer. @see NvDsInferSegmentationMeta for details."]
pub const NvDsMetaType_NVDSINFER_SEGMENTATION_META: NvDsMetaType = 13;
#[doc = " Specifies metadata type for JPEG-encoded object crops.\n See the deepstream-image-meta-test app for details."]
pub const NvDsMetaType_NVDS_CROP_IMAGE_META: NvDsMetaType = 14;
#[doc = " metadata type to be set for tracking previous frames"]
pub const NvDsMetaType_NVDS_TRACKER_PAST_FRAME_META: NvDsMetaType = 15;
#[doc = " Specifies metadata type for formed audio batch."]
pub const NvDsMetaType_NVDS_AUDIO_BATCH_META: NvDsMetaType = 16;
#[doc = " Specifies metadata type for audio frame."]
pub const NvDsMetaType_NVDS_AUDIO_FRAME_META: NvDsMetaType = 17;
#[doc = " Specifies metadata type for preprocess scale&converted ROIs attached by Gst-nvdspreprocess.\n@see NvDsPreProcessFrameMeta for details."]
pub const NvDsMetaType_NVDS_PREPROCESS_FRAME_META: NvDsMetaType = 18;
#[doc = " Specifies metadata type for preprocess batch level attached by Gst-nvdspreprocess.\n@see NvDsPreProcessBatchMeta for details."]
pub const NvDsMetaType_NVDS_PREPROCESS_BATCH_META: NvDsMetaType = 19;
#[doc = " Specifies user defined custom message blob to be part of payload generated"]
pub const NvDsMetaType_NVDS_CUSTOM_MSG_BLOB: NvDsMetaType = 20;
#[doc = " Reserved field"]
pub const NvDsMetaType_NVDS_RESERVED_META: NvDsMetaType = 4095;
#[doc = " Specifies the start of a range of enum values that represent types of\n NVIDIA-defined Gst metas. The range is from NVDS_GST_CUSTOM_META to\n NVDS_GST_CUSTOM_META+4096, inclusive."]
pub const NvDsMetaType_NVDS_GST_CUSTOM_META: NvDsMetaType = 4096;
#[doc = " Start adding user specific meta types from here */\n/**\n Specifies the start of a range of enum values that represent custom\n (application-specific) Gst meta types. A custom meta type may be assigned\n any enum value equal to or larger than this.\n\n Such Gst metas may be attached by GStreamer plugins upstream from\n Gst-nvstreammux. They may have any contents that is a superset of\n the metadata in an @ref NvDsFrameMeta."]
pub const NvDsMetaType_NVDS_START_USER_META: NvDsMetaType = 8193;
#[doc = " Start adding user specific meta types from here */\n/**\n Specifies the start of a range of enum values that represent custom\n (application-specific) Gst meta types. A custom meta type may be assigned\n any enum value equal to or larger than this.\n\n Such Gst metas may be attached by GStreamer plugins upstream from\n Gst-nvstreammux. They may have any contents that is a superset of\n the metadata in an @ref NvDsFrameMeta."]
pub const NvDsMetaType_NVDS_FORCE32_META: NvDsMetaType = 2147483647;
#[doc = " Specifies the type of metadata. All metadata types are subtypes of\n @ref NvDsMetaType. Members that represent NVIDIA-defined types are\n in the range from @ref NVDS_BATCH_META to @ref NVDS_START_USER_META.\n User-defined types may be assigned values greater than or equal to\n @ref NVDS_START_USER_META."]
pub type NvDsMetaType = ::std::os::raw::c_int;
#[doc = " Holds unclipped positional bounding box coordinates of the object processed\n by the component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsComp_BboxInfo {
    pub org_bbox_coords: NvBbox_Coords,
}
#[test]
fn bindgen_test_layout__NvDsComp_BboxInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsComp_BboxInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsComp_BboxInfo>(),
        16usize,
        concat!("Size of: ", stringify!(_NvDsComp_BboxInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsComp_BboxInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(_NvDsComp_BboxInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).org_bbox_coords) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsComp_BboxInfo),
            "::",
            stringify!(org_bbox_coords)
        )
    );
}
#[doc = " Holds unclipped positional bounding box coordinates of the object processed\n by the component."]
pub type NvDsComp_BboxInfo = _NvDsComp_BboxInfo;
#[doc = " Holds information about a given metadata pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsMetaPool {
    pub meta_type: NvDsMetaType,
    pub max_elements_in_pool: guint,
    pub element_size: guint,
    pub num_empty_elements: guint,
    pub num_full_elements: guint,
    pub empty_list: *mut NvDsMetaList,
    pub full_list: *mut NvDsMetaList,
    pub copy_func: NvDsMetaCopyFunc,
    pub release_func: NvDsMetaReleaseFunc,
}
#[test]
fn bindgen_test_layout__NvDsMetaPool() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsMetaPool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsMetaPool>(),
        56usize,
        concat!("Size of: ", stringify!(_NvDsMetaPool))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsMetaPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsMetaPool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(meta_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_elements_in_pool) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(max_elements_in_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(element_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_empty_elements) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(num_empty_elements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_full_elements) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(num_full_elements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).empty_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(empty_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_list) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(full_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(copy_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(release_func)
        )
    );
}
#[doc = " Holds information about a given metadata pool."]
pub type NvDsMetaPool = _NvDsMetaPool;
#[doc = " Holds information about base metadata of a given metadata type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsBaseMeta {
    #[doc = " Holds a pointer to batch_meta @ref NvDsBatchMeta."]
    pub batch_meta: *mut _NvDsBatchMeta,
    #[doc = " Holds the metadata type of this metadata element."]
    pub meta_type: NvDsMetaType,
    #[doc = " Holds a pointer to a user context."]
    pub uContext: *mut ::std::os::raw::c_void,
    #[doc = " Holds a user-defined copy function. The function is called to copy\nor transform metadata from one buffer to another. @a meta_data and\n@a user_data are passed as arguments."]
    pub copy_func: NvDsMetaCopyFunc,
    #[doc = " Holds a user-defined release function. The function is called\nwhen @a meta_data is to be released."]
    pub release_func: NvDsMetaReleaseFunc,
}
#[test]
fn bindgen_test_layout__NvDsBaseMeta() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsBaseMeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsBaseMeta>(),
        40usize,
        concat!("Size of: ", stringify!(_NvDsBaseMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsBaseMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsBaseMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batch_meta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBaseMeta),
            "::",
            stringify!(batch_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBaseMeta),
            "::",
            stringify!(meta_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uContext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBaseMeta),
            "::",
            stringify!(uContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBaseMeta),
            "::",
            stringify!(copy_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBaseMeta),
            "::",
            stringify!(release_func)
        )
    );
}
#[doc = " Holds information about base metadata of a given metadata type."]
pub type NvDsBaseMeta = _NvDsBaseMeta;
#[doc = " Holds information about a formed batch containing frames from different\n sources.\n NOTE: Both Video and Audio metadata uses the same NvDsBatchMeta type.\n NOTE: Audio batch metadata is formed within nvinferaudio plugin\n and will not be corresponding to any one buffer output from nvinferaudio.\n The NvDsBatchMeta for audio is attached to the last input buffer\n when the audio batch buffering reach configurable threshold\n (audio frame length) and this is when inference output is available."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsBatchMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the maximum number of frames in the batch."]
    pub max_frames_in_batch: guint,
    #[doc = " Holds the number of frames now in the batch."]
    pub num_frames_in_batch: guint,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsFrameMeta,\nrepresenting a pool of frame metas."]
    pub frame_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type NvDsObjMeta,\nrepresenting a pool of object metas."]
    pub obj_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsClassifierMeta,\nrepresenting a pool of classifier metas."]
    pub classifier_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsDisplayMeta,\nrepresenting a pool of display metas."]
    pub display_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsUserMeta,\nrepresenting a pool of user metas."]
    pub user_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsLabelInfo,\nrepresenting a pool of label metas."]
    pub label_info_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a list of pointers of type NvDsFrameMeta\nor NvDsAudioFrameMeta (when the batch represent audio batch),\nrepresenting frame metas used in the current batch."]
    pub frame_meta_list: *mut NvDsFrameMetaList,
    #[doc = " Holds a pointer to a list of pointers of type NvDsUserMeta,\nrepresenting user metas in the current batch."]
    pub batch_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds a lock to be set before accessing metadata to avoid\nsimultaneous update by multiple components."]
    pub meta_mutex: GRecMutex,
    #[doc = " Holds an array of user-specific batch information."]
    pub misc_batch_info: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout__NvDsBatchMeta() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsBatchMeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsBatchMeta>(),
        192usize,
        concat!("Size of: ", stringify!(_NvDsBatchMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsBatchMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsBatchMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_frames_in_batch) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(max_frames_in_batch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_frames_in_batch) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(num_frames_in_batch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_meta_pool) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(frame_meta_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj_meta_pool) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(obj_meta_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classifier_meta_pool) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(classifier_meta_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_meta_pool) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(display_meta_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_meta_pool) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(user_meta_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label_info_meta_pool) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(label_info_meta_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_meta_list) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(frame_meta_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batch_user_meta_list) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(batch_user_meta_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta_mutex) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(meta_mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).misc_batch_info) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(misc_batch_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds information about a formed batch containing frames from different\n sources.\n NOTE: Both Video and Audio metadata uses the same NvDsBatchMeta type.\n NOTE: Audio batch metadata is formed within nvinferaudio plugin\n and will not be corresponding to any one buffer output from nvinferaudio.\n The NvDsBatchMeta for audio is attached to the last input buffer\n when the audio batch buffering reach configurable threshold\n (audio frame length) and this is when inference output is available."]
pub type NvDsBatchMeta = _NvDsBatchMeta;
#[doc = " Holds metadata for a frame in a batch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsFrameMeta {
    #[doc = " Holds the base metadata for the frame."]
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the pad or port index of the Gst-streammux plugin for the frame\nin the batch."]
    pub pad_index: guint,
    #[doc = " Holds the location of the frame in the batch. The frame's\n@ref NvBufSurfaceParams are at index @a batch_id in the @a surfaceList\narray of @ref NvBufSurface."]
    pub batch_id: guint,
    #[doc = " Holds the current frame number of the source."]
    pub frame_num: gint,
    #[doc = " Holds the presentation timestamp (PTS) of the frame."]
    pub buf_pts: guint64,
    #[doc = " Holds the ntp timestamp."]
    pub ntp_timestamp: guint64,
    #[doc = " Holds the source IDof the frame in the batch, e.g. the camera ID.\nIt need not be in sequential order."]
    pub source_id: guint,
    #[doc = " Holds the number of surfaces in the frame, required in case of\nmultiple surfaces in the frame."]
    pub num_surfaces_per_frame: gint,
    pub source_frame_width: guint,
    pub source_frame_height: guint,
    pub surface_type: guint,
    pub surface_index: guint,
    #[doc = " Holds the number of object meta elements attached to current frame."]
    pub num_obj_meta: guint,
    #[doc = " Holds a Boolean indicating whether inference is performed on the frame."]
    pub bInferDone: gboolean,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsObjectMeta\nin use for the frame."]
    pub obj_meta_list: *mut NvDsObjectMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsDisplayMeta\nin use for the frame."]
    pub display_meta_list: *mut NvDisplayMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta\nin use for the frame."]
    pub frame_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds additional user-defined frame information."]
    pub misc_frame_info: [gint64; 4usize],
    pub pipeline_width: guint,
    pub pipeline_height: guint,
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout__NvDsFrameMeta() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsFrameMeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsFrameMeta>(),
        200usize,
        concat!("Size of: ", stringify!(_NvDsFrameMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsFrameMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsFrameMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad_index) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(pad_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batch_id) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(batch_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_num) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(frame_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_pts) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(buf_pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ntp_timestamp) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(ntp_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_id) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_surfaces_per_frame) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(num_surfaces_per_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_frame_width) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(source_frame_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_frame_height) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(source_frame_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).surface_type) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(surface_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).surface_index) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(surface_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_obj_meta) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(num_obj_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bInferDone) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(bInferDone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj_meta_list) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(obj_meta_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_meta_list) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(display_meta_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_user_meta_list) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(frame_user_meta_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).misc_frame_info) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(misc_frame_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipeline_width) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(pipeline_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipeline_height) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(pipeline_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds metadata for an object in the frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsObjectMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds a pointer to the parent @ref NvDsObjectMeta. Set to NULL if\nno parent exists."]
    pub parent: *mut _NvDsObjectMeta,
    #[doc = " Holds a unique component ID that identifies the metadata\nin this structure."]
    pub unique_component_id: gint,
    #[doc = " Holds the index of the object class inferred by the primary\ndetector/classifier."]
    pub class_id: gint,
    #[doc = " Holds a unique ID for tracking the object. @ref UNTRACKED_OBJECT_ID\nindicates that the object has not been tracked."]
    pub object_id: guint64,
    #[doc = " Holds a structure containing bounding box parameters of the object when\ndetected by detector."]
    pub detector_bbox_info: NvDsComp_BboxInfo,
    #[doc = " Holds a structure containing bounding box coordinates of the object when\n processed by tracker."]
    pub tracker_bbox_info: NvDsComp_BboxInfo,
    #[doc = " Holds a confidence value for the object, set by the inference\ncomponent. confidence will be set to -0.1, if \"Group Rectangles\" mode of\nclustering is chosen since the algorithm does not preserve confidence\nvalues. Also, for objects found by tracker and not inference component,\nconfidence will be set to -0.1"]
    pub confidence: gfloat,
    #[doc = " Holds a confidence value for the object set by nvdcf_tracker.\n tracker_confidence will be set to -0.1 for KLT and IOU tracker"]
    pub tracker_confidence: gfloat,
    #[doc = " Holds a structure containing positional parameters of the object\n processed by the last component that updates it in the pipeline.\n e.g. If the tracker component is after the detector component in the\n pipeline then positinal parameters are from tracker component.\n Positional parameters are clipped so that they do not fall outside frame\n boundary. Can also be used to overlay borders or semi-transparent boxes on\n objects. @see NvOSD_RectParams."]
    pub rect_params: NvOSD_RectParams,
    #[doc = " Holds mask parameters for the object. This mask is overlayed on object\n @see NvOSD_MaskParams."]
    pub mask_params: NvOSD_MaskParams,
    #[doc = " Holds text describing the object. This text can be overlayed on the\nstandard text that identifies the object. @see NvOSD_TextParams."]
    pub text_params: NvOSD_TextParams,
    #[doc = " Holds a string describing the class of the detected object."]
    pub obj_label: [gchar; 128usize],
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsClassifierMeta."]
    pub classifier_meta_list: *mut NvDsClassifierMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta."]
    pub obj_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds additional user-defined object information."]
    pub misc_obj_info: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout__NvDsObjectMeta() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsObjectMeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsObjectMeta>(),
        544usize,
        concat!("Size of: ", stringify!(_NvDsObjectMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsObjectMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsObjectMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unique_component_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(unique_component_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_id) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(class_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_id) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(object_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detector_bbox_info) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(detector_bbox_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tracker_bbox_info) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(tracker_bbox_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).confidence) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(confidence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tracker_confidence) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(tracker_confidence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rect_params) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(rect_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_params) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(mask_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_params) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(text_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj_label) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(obj_label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classifier_meta_list) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(classifier_meta_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj_user_meta_list) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(obj_user_meta_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).misc_obj_info) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(misc_obj_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds metadata for an object in the frame."]
pub type NvDsObjectMeta = _NvDsObjectMeta;
#[doc = " Holds classifier metadata for an object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsClassifierMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the number of outputs/labels produced by the classifier."]
    pub num_labels: guint,
    #[doc = " Holds a unique component ID for the classifier metadata."]
    pub unique_component_id: gint,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsLabelInfo."]
    pub label_info_list: *mut NvDsLabelInfoList,
    #[doc = " Holds the type of the classifier."]
    pub classifier_type: *const gchar,
}
#[test]
fn bindgen_test_layout__NvDsClassifierMeta() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsClassifierMeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsClassifierMeta>(),
        64usize,
        concat!("Size of: ", stringify!(_NvDsClassifierMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsClassifierMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsClassifierMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsClassifierMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_labels) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsClassifierMeta),
            "::",
            stringify!(num_labels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unique_component_id) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsClassifierMeta),
            "::",
            stringify!(unique_component_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label_info_list) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsClassifierMeta),
            "::",
            stringify!(label_info_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classifier_type) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsClassifierMeta),
            "::",
            stringify!(classifier_type)
        )
    );
}
#[doc = " Holds classifier metadata for an object."]
pub type NvDsClassifierMeta = _NvDsClassifierMeta;
#[doc = " Holds label metadata for the classifier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsLabelInfo {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the number of classes of the given label."]
    pub num_classes: guint,
    #[doc = " Holds an string describing the label of the classified object."]
    pub result_label: [gchar; 128usize],
    #[doc = " Holds a pointer to the result label if its length exceeds MAX_LABEL_SIZE bytes."]
    pub pResult_label: *mut gchar,
    #[doc = " Holds the class UD of the best result."]
    pub result_class_id: guint,
    #[doc = " Holds the label ID in case there are multiple label classifiers."]
    pub label_id: guint,
    #[doc = " Holds the probability of best result."]
    pub result_prob: gfloat,
}
#[test]
fn bindgen_test_layout__NvDsLabelInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsLabelInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsLabelInfo>(),
        200usize,
        concat!("Size of: ", stringify!(_NvDsLabelInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsLabelInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsLabelInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_classes) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(num_classes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_label) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(result_label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pResult_label) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(pResult_label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_class_id) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(result_class_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label_id) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(label_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_prob) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(result_prob)
        )
    );
}
#[doc = " Holds label metadata for the classifier."]
pub type NvDsLabelInfo = _NvDsLabelInfo;
#[doc = " Holds display metadata that the user can specify in the frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsDisplayMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the number of rectangles described."]
    pub num_rects: guint,
    #[doc = " Holds the number of labels (strings) described."]
    pub num_labels: guint,
    #[doc = " Holds the number of lines described."]
    pub num_lines: guint,
    #[doc = " Holds the number of arrows described."]
    pub num_arrows: guint,
    #[doc = " Holds the number of circles described."]
    pub num_circles: guint,
    #[doc = " Holds an array of positional parameters for rectangles.\nUsed to overlay borders or semi-transparent rectangles,\nas required by the application. @see NvOSD_RectParams."]
    pub rect_params: [NvOSD_RectParams; 16usize],
    #[doc = " Holds an array of text parameters for user-defined strings that can be\noverlayed using this structure. @see NvOSD_TextParams."]
    pub text_params: [NvOSD_TextParams; 16usize],
    #[doc = " Holds an array of line parameters that the user can use to draw polygons\nin the frame, e.g. to show a RoI in the frame. @see NvOSD_LineParams."]
    pub line_params: [NvOSD_LineParams; 16usize],
    #[doc = " Holds an array of arrow parameters that the user can use to draw arrows\nin the frame. @see NvOSD_ArrowParams"]
    pub arrow_params: [NvOSD_ArrowParams; 16usize],
    #[doc = " Holds an array of circle parameters that the user can use to draw circles\nin the frame. @see NvOSD_CircleParams"]
    pub circle_params: [NvOSD_CircleParams; 16usize],
    #[doc = " Holds an array of user-defined OSD metadata."]
    pub misc_osd_data: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout_NvDsDisplayMeta() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsDisplayMeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsDisplayMeta>(),
        6912usize,
        concat!("Size of: ", stringify!(NvDsDisplayMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsDisplayMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsDisplayMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_rects) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(num_rects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_labels) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(num_labels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_lines) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(num_lines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_arrows) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(num_arrows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_circles) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(num_circles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rect_params) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(rect_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_params) as usize - ptr as usize },
        1728usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(text_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_params) as usize - ptr as usize },
        3392usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(line_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrow_params) as usize - ptr as usize },
        4288usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(arrow_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).circle_params) as usize - ptr as usize },
        5312usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(circle_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).misc_osd_data) as usize - ptr as usize },
        6848usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(misc_osd_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        6880usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds user metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsUserMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds a pointer to user data to be attached.\nSee the deepstream-user-metadata-test example for usage."]
    pub user_meta_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__NvDsUserMeta() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsUserMeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsUserMeta>(),
        48usize,
        concat!("Size of: ", stringify!(_NvDsUserMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsUserMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsUserMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsUserMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_meta_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsUserMeta),
            "::",
            stringify!(user_meta_data)
        )
    );
}
#[doc = " Holds user metadata."]
pub type NvDsUserMeta = _NvDsUserMeta;
extern "C" {
    #[doc = " Acquires a lock before updating metadata.\n\n @param[in] batch_meta    A pointer to the NvDsBatchMeta structure\n                          to be locked."]
    pub fn nvds_acquire_meta_lock(batch_meta: *mut NvDsBatchMeta);
}
extern "C" {
    #[doc = " Releases the lock after updating metadata.\n\n @param[in] batch_meta    A pointer to NvDsBatchMeta structure to be unlocked."]
    pub fn nvds_release_meta_lock(batch_meta: *mut NvDsBatchMeta);
}
extern "C" {
    #[doc = " Creates a batch metadata structure for a batch of specified size.\n\n @param[in] max_batch_size    The maximum number of frames in the batch.\n @ return  A pointer to the created structure."]
    pub fn nvds_create_batch_meta(max_batch_size: guint) -> *mut NvDsBatchMeta;
}
extern "C" {
    #[doc = " Destroys a batch metadata structure.\n\n @param[in] batch_meta    A pointer to batch metadata structure\n                          to be destroyed.\n @returns  True if the object was successfully destroyed, or false otherwise."]
    pub fn nvds_destroy_batch_meta(batch_meta: *mut NvDsBatchMeta) -> gboolean;
}
extern "C" {
    #[doc = " \\brief  Acquires a frame meta from a batch's frame meta pool.\n\n You must acquire a frame meta before you can fill it with frame metadata.\n\n @param[in] batch_meta    A pointer to batch meta from which to acquire\n                          a frame meta.\n\n @return  A pointer to the acquired frame meta."]
    pub fn nvds_acquire_frame_meta_from_pool(batch_meta: *mut NvDsBatchMeta) -> *mut NvDsFrameMeta;
}
extern "C" {
    #[doc = " Adds a frame meta to a batch meta.\n\n @param[in] batch_meta    A pointer to the NvDsBatchMeta to which\n                          @a frame_meta is to be added.\n @param[in] frame_meta    A pointer to a frame meta to be added to\n                          @a batch_meta."]
    pub fn nvds_add_frame_meta_to_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " Removes a frame meta from a batch meta.\n\n @param[in] batch_meta    A pointer to the batch meta from which @a frame_meta\n                          is to be removed.\n @param[in] frame_meta    A pointer to the frame meta to be removed from\n                          @a batch_meta."]
    pub fn nvds_remove_frame_meta_from_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " @brief  Acquires an object meta from a batch meta's object meta pool.\n\n You must acquire an object meta before you can fill it with object metadata.\n\n @param[in] batch_meta    A pointer to the batch meta from which to acquire\n                          an object meta.\n\n @return  A pointer to the acquired object meta."]
    pub fn nvds_acquire_obj_meta_from_pool(batch_meta: *mut NvDsBatchMeta) -> *mut NvDsObjectMeta;
}
extern "C" {
    #[doc = " @brief  Adds an object meta to a frame meta.\n\n You must acquire the object meta with nvds_acquire_object_meta_from_pool()\n and fill it with metadata before you add to to the frame meta.\n\n @param[in] frame_meta    A pointer to the frame meta to which @a obj_meta\n                          is to be added.\n @param[in] obj_meta      A pointer to an object meta to be added to @a frame_meta.\n @param[in] obj_parent    A pointer to the this object meta's parent object meta.\n                          This pointer is stored in @a obj_meta->parent."]
    pub fn nvds_add_obj_meta_to_frame(
        frame_meta: *mut NvDsFrameMeta,
        obj_meta: *mut NvDsObjectMeta,
        obj_parent: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " Removes an object meta from the frame meta to which it is attached.\n\n @param[in] frame_meta    A pointer to frame meta from which @a obj_meta\n                          is to be removed.\n @param[in] obj_meta      A pointer to the object meta to be removed from\n                          @a frame_meta."]
    pub fn nvds_remove_obj_meta_from_frame(
        frame_meta: *mut NvDsFrameMeta,
        obj_meta: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " @brief  Acquires a classifier meta from a batch meta's classifier meta pool.\n\n You must acquire a classifier meta from the classifier meta pool before you\n can fill it with classifier metadata.\n\n @param[in] batch_meta    A pointer to the batch meta from which to acquire\n                          a classifier meta.\n\n @return  The classifier meta acquired from the batch meta's\n  classifier meta pool."]
    pub fn nvds_acquire_classifier_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsClassifierMeta;
}
extern "C" {
    #[doc = " @brief  Adds a classifier meta to the appropriate roi meta.\n\n You must acquire a classifier meta with\n nvds_acquire_classifier_meta_from_pool() and fill it with\n classifier metadata before you add it to the roi metadata.\n\n @param[in] roi_meta          A pointer to the roi meta to which\n                              @a classifier_meta is to be added.\n @param[in] classifier_meta   A pointer to the classifier meta to be added\n                              to @a roi_meta."]
    pub fn nvds_add_classifier_meta_to_roi(
        roi_meta: *mut NvDsRoiMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Removes a classifier meta from the roi meta to which it is attached.\n\n @param[in] roi_meta          A pointer to the roi meta from which\n                              @a classifier_meta is to be removed.\n @param[in] classifier_meta   A pointer to the classifier meta to be removed\n                              from @a roi_meta."]
    pub fn nvds_remove_classifier_meta_from_roi(
        roi_meta: *mut NvDsRoiMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " @brief  Adds a classifier meta to the appropriate object meta.\n\n You must acquire a classifier meta with\n nvds_acquire_classifier_meta_from_pool() and fill it with\n classifier metadata before you add it to the object metadata.\n\n @param[in] obj_meta          A pointer to the object meta to which\n                              @a classifier_meta is to be added.\n @param[in] classifier_meta   A pointer to the classifier meta to be added\n                              to @a obj_meta."]
    pub fn nvds_add_classifier_meta_to_object(
        obj_meta: *mut NvDsObjectMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Removes a classifier meta from the object meta to which it is attached.\n\n @param[in] obj_meta          A pointer to the object meta from which\n                              @a classifier_meta is to be removed.\n @param[in] classifier_meta   A pointer to the classifier meta to be removed\n                              from @a obj_meta."]
    pub fn nvds_remove_classifier_meta_from_obj(
        obj_meta: *mut NvDsObjectMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " @brief  Acquires a display meta from a batch meta's display meta pool.\n\n You must acquire a display meta before you can fill it with display metadata.\n\n @param[in] batch_meta    A pointer to the batch meta from which to acquire\n                          a display meta.\n\n @return  The display meta acquired from the batch meta's display meta pool."]
    pub fn nvds_acquire_display_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsDisplayMeta;
}
extern "C" {
    #[doc = " @brief  Adds a display meta to the appropriate frame meta.\n\n You must acquire a display meta with nvds_)acquire_display_meta_from_pool()\n and fill it with display metadata before you can add it to the frame meta.\n\n @param[in] frame_meta    A pointer to frame meta to which @a display_meta\n                          is to be added.\n @param[in] display_meta  A pointer to the display meta to be added to\n                          @a frame_meta."]
    pub fn nvds_add_display_meta_to_frame(
        frame_meta: *mut NvDsFrameMeta,
        display_meta: *mut NvDsDisplayMeta,
    );
}
extern "C" {
    #[doc = " Removes a display meta from the frame meta to which it is attached.\n\n @param[in] frame_meta    A pointer to the frame meta from which\n                          @a display_meta is to be removed.\n @param[in] display_meta  A pointer to the display meta to be removed from\n                          @a frame_meta."]
    pub fn nvds_remove_display_meta_from_frame(
        frame_meta: *mut NvDsFrameMeta,
        display_meta: *mut NvDsDisplayMeta,
    );
}
extern "C" {
    #[doc = " @brief  Acquires a label info meta from a batch meta's label info meta pool.\n\n You must acquire a label info meta before you can fill it and add it to a\n classifier meta.\n\n @param[in] batch_meta    A pointer to the batch meta from which to acquire\n                          a label info meta.\n\n @return  The label info meta acquired from the batch meta's\n  label info meta pool."]
    pub fn nvds_acquire_label_info_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsLabelInfo;
}
extern "C" {
    #[doc = " Adds a label info meta to a classifier meta.\n\n @param[in] classifier_meta   A pointer to the classifier meta to which\n                              @a label_info_meta is to be added.\n @param[in] label_info_meta   A pointer to the label info meta to be added\n                              to @a classifier_meta."]
    pub fn nvds_add_label_info_meta_to_classifier(
        classifier_meta: *mut NvDsClassifierMeta,
        label_info_meta: *mut NvDsLabelInfo,
    );
}
extern "C" {
    #[doc = " Removes a label info meta from the classifier meta to which it is attached.\n\n @param[in] classifier_meta   A pointer to the classifier meta from which\n                              @a label_info_meta is to be removed.\n @param[in] label_info_meta   A pointer to the label info meta to be removed\n                              from @a classifier_meta."]
    pub fn nvds_remove_label_info_meta_from_classifier(
        classifier_meta: *mut NvDsClassifierMeta,
        label_info_meta: *mut NvDsLabelInfo,
    );
}
extern "C" {
    #[doc = " Add a user meta to a batch meta.\n\n @param[in] batch_meta    A pointer to batch meta to which @a user_meta\n                          is to be added.\n @param[in] user_meta     A pointer to a user meta to be added to\n                          @a batch_meta."]
    pub fn nvds_add_user_meta_to_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Add a user meta to a frame meta.\n\n @param[in] frame_meta    A pointer to the frame meta to which @a user_meta\n                          is to be added.\n @param[in] user_meta     A pointer to a user meta to be added to\n                          @a frame_meta."]
    pub fn nvds_add_user_meta_to_frame(
        frame_meta: *mut NvDsFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Add a user meta user to an roi meta.\n\n @param[in] roi_meta      A pointer to the roi meta to which @a user_meta\n                          is to be added.\n @param[in] user_meta     A pointer to the user meta to be added to\n                          @a roi_meta."]
    pub fn nvds_add_user_meta_to_roi(roi_meta: *mut NvDsRoiMeta, user_meta: *mut NvDsUserMeta);
}
extern "C" {
    #[doc = " Add a user meta user to an object meta.\n\n @param[in] obj_meta      A pointer to the object meta to which @a user_meta\n                          is to be added.\n @param[in] user_meta     A pointer to the user meta to be added to\n                          @a obj_meta."]
    pub fn nvds_add_user_meta_to_obj(obj_meta: *mut NvDsObjectMeta, user_meta: *mut NvDsUserMeta);
}
extern "C" {
    #[doc = " @brief  Acquires a user meta from a batch meta's user meta pool.\n\n You must acquire a user meta before you can fill it with user metdata and\n add it to a batch, frame, or object meta (call nvds_add_user_data_to_batch(),\n  nvds_add_user_data_to_frame(), or nvds_add_user_data_to_obj()).\n\n @param[in] batch_meta    A pointer to the batch meta from which to acquire\n                          a user meta."]
    pub fn nvds_acquire_user_meta_from_pool(batch_meta: *mut NvDsBatchMeta) -> *mut NvDsUserMeta;
}
extern "C" {
    #[doc = " Removes a user meta from a batch meta to which it is attached.\n\n @param[in] batch_meta    A pointer to the batch meta from which @a user_meta\n                          is to be removed.\n @param[in] user_meta     A pointer to the user meta to be removed from\n                          @a batch_meta.\n\n returns acquired @ref NvDsUserMeta pointer from user meta pool"]
    pub fn nvds_remove_user_meta_from_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Removes a user meta from a frame meta to which it is attached.\n\n @param[in] frame_meta    A pointer to the frame meta from which @a user_meta\n                          is to be removed.\n @param[in] user_meta     A pointer to the user meta to be removed from\n                          @a frame_meta."]
    pub fn nvds_remove_user_meta_from_frame(
        frame_meta: *mut NvDsFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Removes a user meta from an roi meta to which it is attached.\n\n @param[in] roi_meta      A pointer to the roi meta from which @a user_meta\n                          is to be removed.\n @param[in] user_meta     A pointer to the user to be removed from\n                          @a roi_meta."]
    pub fn nvds_remove_user_meta_from_roi(obj_meta: *mut NvDsRoiMeta, user_meta: *mut NvDsUserMeta);
}
extern "C" {
    #[doc = " Removes a user meta from an object meta to which it is attached.\n\n @param[in] obj_meta      A pointer to the object meta from which @a user_meta\n                          is to be removed.\n @param[in] user_meta     A pointer to the user to be removed from\n                          @a obj_meta."]
    pub fn nvds_remove_user_meta_from_object(
        obj_meta: *mut NvDsObjectMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " A debugging function; prints current metadata information available after\n inference. This function should be called after inference.\n\n @param[in] batch_meta    A pointer to a batch meta from which to\n                          print information.\n @return"]
    pub fn nvds_get_current_metadata_info(batch_meta: *mut NvDsBatchMeta) -> gboolean;
}
extern "C" {
    #[doc = " @brief  Copies or transforms meta data from one buffer to another.\n\n @param[in] data      A pointer to a batch meta (of type @ref NvDsBatchMeta),\n                      cast to @c gpointer.\n @param[in] user_data Currently not in use and should be set to NULL.\n\n @return A pointer to a metadata structure, to be cast to type NvDsBatchMeta."]
    pub fn nvds_batch_meta_copy_func(data: gpointer, user_data: gpointer) -> gpointer;
}
extern "C" {
    #[doc = " Releases metadata from a batch meta.\n\n @param[in] data      A pointer to a batch meta (type @ref NvDsBatchMeta),\n                      cast to @c gpointer.\n @param[in] user_data Currently not in use and should be set to NULL."]
    pub fn nvds_batch_meta_release_func(data: gpointer, user_data: gpointer);
}
extern "C" {
    #[doc = " Returns a pointer to a specified frame meta in the frame meta list.\n\n @param[in] frame_meta_list   A pointer to a list of pointers to frame metas.\n @param[in] index             The index of the frame meta to be returned.\n\n @return  A pointer to the @a index'th frame meta in the frame meta list."]
    pub fn nvds_get_nth_frame_meta(
        frame_meta_list: *mut NvDsFrameMetaList,
        index: guint,
    ) -> *mut NvDsFrameMeta;
}
extern "C" {
    #[doc = " Removes all of the frame metadata attached to a batch meta.\n\n @param[in] batch_meta    A pointer to the batch whose frame meta list\n                          is to be cleared.\n @param[in] meta_list     A pointer to the frame meta list to be cleared."]
    pub fn nvds_clear_frame_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsFrameMetaList,
    );
}
extern "C" {
    #[doc = " Removes all the object metadata attached to a frame meta.\n\n @param[in] frame_meta    A pointer to the frame meta whose object meta list\n                          is to be cleared.\n @param[in] meta_list     A pointer to the object meta list to be cleared."]
    pub fn nvds_clear_obj_meta_list(
        frame_meta: *mut NvDsFrameMeta,
        meta_list: *mut NvDsObjectMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the classifier metadata attached to an object meta.\n\n @param[in] obj_meta A pointer to @ref NvDsObjectMeta from which @a\n            NvDsClassifierMetaList needs to be cleared\n @param[in] meta_list A pointer to @ref NvDsClassifierMetaList which needs to\n            be cleared"]
    pub fn nvds_clear_classifier_meta_list(
        obj_meta: *mut NvDsObjectMeta,
        meta_list: *mut NvDsClassifierMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the label info metadata attached to a classifier meta.\n\n @param[in] classifier_meta   A pointer to the classifier meta whose\n                              label info meta list is to be cleared.\n @param[in] meta_list         A pointer to the label info meta list to be\n                              cleared."]
    pub fn nvds_clear_label_info_meta_list(
        classifier_meta: *mut NvDsClassifierMeta,
        meta_list: *mut NvDsLabelInfoList,
    );
}
extern "C" {
    #[doc = " Removes all of the display metadata attached to a frame meta.\n\n @param[in] frame_meta    A pointer to the frame meta whose display meta list\n                          is to be cleared.\n @param[in] meta_list     A pointer to the display meta list to be cleared."]
    pub fn nvds_clear_display_meta_list(
        frame_meta: *mut NvDsFrameMeta,
        meta_list: *mut NvDisplayMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to the batch meta.\n\n @param[in] batch_meta    A pointer to the batch meta whose\n                          user meta list is to be cleared.\n @param[in] meta_list     A pointer to the user meta list to be\n            cleared"]
    pub fn nvds_clear_batch_user_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to the frame meta.\n\n @param[in] frame_meta    A pointer to the frame meta whose\n                          user meta list is to be cleared.\n @param[in] meta_list     A pointer to the user meta list to be cleared."]
    pub fn nvds_clear_frame_user_meta_list(
        frame_meta: *mut NvDsFrameMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to an object meta.\n\n @param[in] object_meta   A pointer to the object meta whose\n                          user meta list is to be cleared.\n @param[in] meta_list     A pointer to the user meta list to be cleared."]
    pub fn nvds_clear_obj_user_meta_list(
        object_meta: *mut NvDsObjectMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the metadata elements attached to a metadata list.\n\n @param[in] batch_meta    A pointer to a batch meta.\n @param[in] meta_list     A pointer to meta list to be cleared.\n @param[in] meta_pool     A pointer to the meta pool that contains\n                          @a meta_list.\n @return  A pointer to the updated meta list."]
    pub fn nvds_clear_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsMetaList,
        meta_pool: *mut NvDsMetaPool,
    ) -> *mut NvDsMetaList;
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a frame meta to another frame meta.\n\n @param[in] src_frame_meta    A pointer to the source frame meta.\n @param[in] dst_frame_meta    A pointer to the destination frame meta."]
    pub fn nvds_copy_frame_meta(
        src_frame_meta: *mut NvDsFrameMeta,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of an object meta to another object meta.\n\n @param[in] src_object_meta   A pointer to the source object meta.\n @param[in] dst_object_meta   A pointer to the destination object meta."]
    pub fn nvds_copy_obj_meta(
        src_object_meta: *mut NvDsObjectMeta,
        dst_object_meta: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a classifier meta to another classifier meta.\n\n @param[in] src_classifier_meta   A pointer to the source classifier meta.\n @param[in] dst_classifier_meta A pointer to the destination classifier meta."]
    pub fn nvds_copy_classifier_meta(
        src_classifier_meta: *mut NvDsClassifierMeta,
        dst_classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a label info meta to another label info meta.\n\n @param[in] src_label_info    A pointer to the source label info meta.\n @param[in] dst_label_info    A pointer to the destination label info meta."]
    pub fn nvds_copy_label_info_meta(
        src_label_info: *mut NvDsLabelInfo,
        dst_label_info: *mut NvDsLabelInfo,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a display meta to another display meta.\n\n @param[in] src_display_meta  A pointer to the source display meta.\n @param[in] dst_display_meta  A pointer to destination display meta."]
    pub fn nvds_copy_display_meta(
        src_display_meta: *mut NvDsDisplayMeta,
        dst_display_meta: *mut NvDsDisplayMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a user meta list to the user meta list\n in a specified batch meta.\n\n @param[in] src_user_meta_list    A pointer to the source user meta list.\n @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_batch_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source user meta list to the user meta list\n in a specified frame meta.\n\n @param[in] src_user_meta_list    A pointer to the source user meta list.\n @param[in] dst_frame_meta        A pointer to the destination frame meta."]
    pub fn nvds_copy_frame_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source user meta list to the user meta list\n in a specified object meta.\n\n @param[in] src_user_meta_list    A pointer to the source user meta list.\n @param[in] dst_object_meta       A pointer to the destination object meta."]
    pub fn nvds_copy_obj_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_object_meta: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source display meta list to the\n  display meta list in a specified frame meta.\n\n @param[in] src_display_meta_list A pointer to the source display meta list.\n @param[in] dst_frame_meta        A pointer to the destination frame meta."]
    pub fn nvds_copy_display_meta_list(
        src_display_meta_list: *mut NvDisplayMetaList,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source frame meta list to the frame meta list\n  in a specified batch meta.\n\n @param[in] src_frame_meta_list   A pointer to the source frame meta list.\n @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_frame_meta_list(
        src_frame_meta_list: *mut NvDsFrameMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source object meta list to the\n  object meta list in a specified frame meta.\n\n @param[in] src_obj_meta_list A pointer to the source object meta list.\n @param[in] dst_frame_meta    A pointer to the destination frame meta."]
    pub fn nvds_copy_obj_meta_list(
        src_obj_meta_list: *mut NvDsObjectMetaList,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source classifier meta list to the\n  classifier meta list in a specified object meta.\n\n @param[in] src_classifier_meta_list  A pointer to the source\n                                      classifier meta list.\n @param[in] dst_object_meta           A pointer to the destination\n                                      object meta."]
    pub fn nvds_copy_classification_list(
        src_classifier_meta_list: *mut NvDsClassifierMetaList,
        dst_object_meta: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source label info meta list to the\n  label info meta list in a specified classifier meta.\n\n @param[in] src_label_info_list   A pointer to the source\n                                  label info meta list.\n @param[in] dst_classifier_meta   A pointer to the destination\n                                  classifier meta."]
    pub fn nvds_copy_label_info_list(
        src_label_info_list: *mut NvDsLabelInfoList,
        dst_classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Generates a unique user metadata type from a specified string describing\n user-specific metadata.\n\n @param[in] meta_descriptor   A pointer to a string describing user-specific\n                              metadata. The string must be in the format\n                              @a ORG_NAME.COMPONENT_NAME.METADATA_DESCRIPTION,\n                              e.g. @c NVIDIA.NVINFER.TENSOR_METADATA."]
    pub fn nvds_get_user_meta_type(meta_descriptor: *mut gchar) -> NvDsMetaType;
}
pub const NvBufAudioFormat_NVBUF_AUDIO_INVALID_FORMAT: NvBufAudioFormat = 0;
pub const NvBufAudioFormat_NVBUF_AUDIO_S8: NvBufAudioFormat = 1;
pub const NvBufAudioFormat_NVBUF_AUDIO_U8: NvBufAudioFormat = 2;
pub const NvBufAudioFormat_NVBUF_AUDIO_S16LE: NvBufAudioFormat = 3;
pub const NvBufAudioFormat_NVBUF_AUDIO_S16BE: NvBufAudioFormat = 4;
pub const NvBufAudioFormat_NVBUF_AUDIO_U16LE: NvBufAudioFormat = 5;
pub const NvBufAudioFormat_NVBUF_AUDIO_U16BE: NvBufAudioFormat = 6;
pub const NvBufAudioFormat_NVBUF_AUDIO_S24_32LE: NvBufAudioFormat = 7;
pub const NvBufAudioFormat_NVBUF_AUDIO_S24_32BE: NvBufAudioFormat = 8;
pub const NvBufAudioFormat_NVBUF_AUDIO_U24_32LE: NvBufAudioFormat = 9;
pub const NvBufAudioFormat_NVBUF_AUDIO_U24_32BE: NvBufAudioFormat = 10;
pub const NvBufAudioFormat_NVBUF_AUDIO_S32LE: NvBufAudioFormat = 11;
pub const NvBufAudioFormat_NVBUF_AUDIO_S32BE: NvBufAudioFormat = 12;
pub const NvBufAudioFormat_NVBUF_AUDIO_U32LE: NvBufAudioFormat = 13;
pub const NvBufAudioFormat_NVBUF_AUDIO_U32BE: NvBufAudioFormat = 14;
pub const NvBufAudioFormat_NVBUF_AUDIO_S24LE: NvBufAudioFormat = 15;
pub const NvBufAudioFormat_NVBUF_AUDIO_S24BE: NvBufAudioFormat = 16;
pub const NvBufAudioFormat_NVBUF_AUDIO_U24LE: NvBufAudioFormat = 17;
pub const NvBufAudioFormat_NVBUF_AUDIO_U24BE: NvBufAudioFormat = 18;
pub const NvBufAudioFormat_NVBUF_AUDIO_S20LE: NvBufAudioFormat = 19;
pub const NvBufAudioFormat_NVBUF_AUDIO_S20BE: NvBufAudioFormat = 20;
pub const NvBufAudioFormat_NVBUF_AUDIO_U20LE: NvBufAudioFormat = 21;
pub const NvBufAudioFormat_NVBUF_AUDIO_U20BE: NvBufAudioFormat = 22;
pub const NvBufAudioFormat_NVBUF_AUDIO_S18LE: NvBufAudioFormat = 23;
pub const NvBufAudioFormat_NVBUF_AUDIO_S18BE: NvBufAudioFormat = 24;
pub const NvBufAudioFormat_NVBUF_AUDIO_U18LE: NvBufAudioFormat = 25;
pub const NvBufAudioFormat_NVBUF_AUDIO_U18BE: NvBufAudioFormat = 26;
pub const NvBufAudioFormat_NVBUF_AUDIO_F32LE: NvBufAudioFormat = 27;
pub const NvBufAudioFormat_NVBUF_AUDIO_F32BE: NvBufAudioFormat = 28;
pub const NvBufAudioFormat_NVBUF_AUDIO_F64LE: NvBufAudioFormat = 29;
pub const NvBufAudioFormat_NVBUF_AUDIO_F64BE: NvBufAudioFormat = 30;
#[doc = " Specifies audio formats"]
pub type NvBufAudioFormat = ::std::os::raw::c_uint;
pub const NvBufAudioLayout_NVBUF_AUDIO_INVALID_LAYOUT: NvBufAudioLayout = 0;
#[doc = "< audio sample from each channel shall be interleaved LRLRLRLR"]
pub const NvBufAudioLayout_NVBUF_AUDIO_INTERLEAVED: NvBufAudioLayout = 1;
#[doc = "< audio sample from each channel shall be interleaved ; LLLLLLLLRRRRRRRR"]
pub const NvBufAudioLayout_NVBUF_AUDIO_NON_INTERLEAVED: NvBufAudioLayout = 2;
#[doc = " Specifies audio data layout in memory"]
pub type NvBufAudioLayout = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufAudioParams {
    pub layout: NvBufAudioLayout,
    pub format: NvBufAudioFormat,
    #[doc = "< Bytes per frame; the size of a frame;\n size of one sample * @channels"]
    pub bpf: u32,
    #[doc = "< Number of audio channels"]
    pub channels: u32,
    #[doc = "< audio sample rate in samples per second"]
    pub rate: u32,
    pub dataSize: u32,
    pub dataPtr: *mut ::std::os::raw::c_void,
    #[doc = " Holds the pad or port index of the Gst-streammux plugin for the frame\n in the batch."]
    pub padId: u32,
    #[doc = " source ID of this buffer;\n This is w.r.t the multisrc DeepStream usecases"]
    pub sourceId: u32,
    #[doc = " NTP Timestamp of this audio buffer"]
    pub ntpTimestamp: u64,
    #[doc = " Buffer PTS of this audio buffer"]
    pub bufPts: u64,
    #[doc = " duration of this audio buffer"]
    pub duration: u64,
    pub reserved: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_NvBufAudioParams() {
    const UNINIT: ::std::mem::MaybeUninit<NvBufAudioParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvBufAudioParams>(),
        80usize,
        concat!("Size of: ", stringify!(NvBufAudioParams))
    );
    assert_eq!(
        ::std::mem::align_of::<NvBufAudioParams>(),
        8usize,
        concat!("Alignment of ", stringify!(NvBufAudioParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(bpf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataPtr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(dataPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(padId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceId) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(sourceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ntpTimestamp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(ntpTimestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufPts) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(bufPts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudioParams),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufAudio {
    #[doc = " The size of this NvBufAudio batch"]
    pub numFilled: u32,
    #[doc = " The size of this NvBufAudio batch"]
    pub batchSize: u32,
    #[doc = " isContiguous is true when\n the dataPtr in audioBuffers[] array is\n contiguous with the previous and following entry\n in the array"]
    pub isContiguous: bool,
    #[doc = " Array of #batchSize audio bufffers"]
    pub audioBuffers: *mut NvBufAudioParams,
}
#[test]
fn bindgen_test_layout_NvBufAudio() {
    const UNINIT: ::std::mem::MaybeUninit<NvBufAudio> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvBufAudio>(),
        24usize,
        concat!("Size of: ", stringify!(NvBufAudio))
    );
    assert_eq!(
        ::std::mem::align_of::<NvBufAudio>(),
        8usize,
        concat!("Alignment of ", stringify!(NvBufAudio))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numFilled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudio),
            "::",
            stringify!(numFilled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batchSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudio),
            "::",
            stringify!(batchSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isContiguous) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudio),
            "::",
            stringify!(isContiguous)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioBuffers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufAudio),
            "::",
            stringify!(audioBuffers)
        )
    );
}
#[doc = " Holds metadata for a audio frame in a batch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsAudioFrameMeta {
    #[doc = " Holds the base metadata for the frame."]
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the pad or port index of the Gst-streammux plugin for the frame\nin the batch."]
    pub pad_index: guint,
    #[doc = " Holds the location of the frame in the batch."]
    pub batch_id: guint,
    #[doc = " Holds the current frame number of the source."]
    pub frame_num: gint,
    #[doc = " Holds the presentation timestamp (PTS) of the frame."]
    pub buf_pts: guint64,
    #[doc = " Holds the ntp timestamp."]
    pub ntp_timestamp: guint64,
    #[doc = " Holds the source IDof the frame in the batch, e.g. the camera ID.\nIt need not be in sequential order."]
    pub source_id: guint,
    #[doc = " Holds the number of samples in the frame"]
    pub num_samples_per_frame: gint,
    pub sample_rate: guint,
    pub num_channels: guint,
    pub format: NvBufAudioFormat,
    pub layout: NvBufAudioLayout,
    #[doc = " Holds a Boolean indicating whether inference is performed on the frame."]
    pub bInferDone: gboolean,
    #[doc = " Holds the index of the last object class inferred by the primary\ndetector/classifier."]
    pub class_id: gint,
    #[doc = " Hold confidence for last event detected (last NvDsClassifierMeta)"]
    pub confidence: gfloat,
    #[doc = " Holds a string describing the class of the detected event."]
    pub class_label: [gchar; 128usize],
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsClassifierMeta\nin use for the frame."]
    pub classifier_meta_list: *mut NvDsClassifierMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta\nin use for the frame."]
    pub frame_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds additional user-defined frame information."]
    pub misc_frame_info: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout__NvDsAudioFrameMeta() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsAudioFrameMeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsAudioFrameMeta>(),
        320usize,
        concat!("Size of: ", stringify!(_NvDsAudioFrameMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsAudioFrameMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsAudioFrameMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad_index) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(pad_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batch_id) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(batch_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_num) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(frame_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_pts) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(buf_pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ntp_timestamp) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(ntp_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_id) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_samples_per_frame) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(num_samples_per_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_channels) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(num_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bInferDone) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(bInferDone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_id) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(class_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).confidence) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(confidence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_label) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(class_label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classifier_meta_list) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(classifier_meta_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_user_meta_list) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(frame_user_meta_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).misc_frame_info) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(misc_frame_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds metadata for a audio frame in a batch."]
pub type NvDsAudioFrameMeta = _NvDsAudioFrameMeta;
extern "C" {
    #[doc = " Creates a batch metadata structure for a audio batch of specified size.\n\n @param[in] max_batch_size    The maximum number of frames in the batch.\n @ return  A pointer to the created structure."]
    pub fn nvds_create_audio_batch_meta(max_batch_size: guint) -> *mut NvDsBatchMeta;
}
extern "C" {
    #[doc = " Destroys a batch metadata structure.\n\n @param[in] batch_meta    A pointer to audio batch metadata structure\n                          to be destroyed.\n @returns  True if the object was successfully destroyed, or false otherwise."]
    pub fn nvds_destroy_audio_batch_meta(batch_meta: *mut NvDsBatchMeta) -> gboolean;
}
extern "C" {
    #[doc = " \\brief  Acquires a audio frame meta from a batch's audio frame meta pool.\n\n You must acquire a audio frame meta before you can fill it with audio frame metadata.\n\n @param[in] batch_meta    A pointer to batch meta from which to acquire\n                          a audio frame meta.\n\n @return  A pointer to the acquired audio frame meta."]
    pub fn nvds_acquire_audio_frame_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsAudioFrameMeta;
}
extern "C" {
    #[doc = " Adds a audio frame meta to a batch meta.\n\n @param[in] batch_meta    A pointer to the NvDsBatchMeta to which\n                          @a frame_meta is to be added.\n @param[in] frame_meta    A pointer to a frame meta to be added to\n                          @a batch_meta."]
    pub fn nvds_add_audio_frame_meta_to_audio_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsAudioFrameMeta,
    );
}
extern "C" {
    #[doc = " Removes a audio frame meta from a batch meta.\n\n @param[in] batch_meta    A pointer to the batch meta from which @a frame_meta\n                          is to be removed.\n @param[in] frame_meta    A pointer to the frame meta to be removed from\n                          @a batch_meta."]
    pub fn nvds_remove_audio_frame_meta_from_audio_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsAudioFrameMeta,
    );
}
extern "C" {
    #[doc = " @brief  Adds a classifier meta the audio frame meta.\n\n You must acquire a classifier meta with\n nvds_acquire_classifier_meta_from_pool() and fill it with\n classifier metadata before you add it to the audio frame metadata.\n\n @param[in] frame_meta        A pointer to the frame meta to which\n                              @a classifier_meta is to be added.\n @param[in] classifier_meta   A pointer to the classifier meta to be added\n                              to @a obj_meta."]
    pub fn nvds_add_classifier_meta_to_audio_frame(
        frame_meta: *mut NvDsAudioFrameMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Removes a classifier meta from the audio frame meta to which it is attached.\n\n @param[in] frame_meta          A pointer to the frame meta from which\n                              @a classifier_meta is to be removed.\n @param[in] classifier_meta   A pointer to the classifier meta to be removed\n                              from @a frame_meta."]
    pub fn nvds_remove_classifier_meta_from_audio_frame(
        frame_meta: *mut NvDsAudioFrameMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Add a user meta to a audio batch meta.\n\n @param[in] batch_meta    A pointer to batch meta to which @a user_meta\n                          is to be added.\n @param[in] user_meta     A pointer to a user meta to be added to\n                          @a batch_meta."]
    pub fn nvds_add_user_meta_to_audio_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Add a user meta to a audio frame meta.\n\n @param[in] frame_meta    A pointer to the frame meta to which @a user_meta\n                          is to be added.\n @param[in] user_meta     A pointer to a user meta to be added to\n                          @a frame_meta."]
    pub fn nvds_add_user_meta_to_audio_frame(
        frame_meta: *mut NvDsAudioFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Removes a user meta from a audio batch meta to which it is attached.\n\n @param[in] batch_meta    A pointer to the audio batch meta from which @a user_meta\n                          is to be removed.\n @param[in] user_meta     A pointer to the user meta to be removed from\n                          @a batch_meta.\n\n returns acquired @ref NvDsUserMeta pointer from user meta pool"]
    pub fn nvds_remove_user_meta_from_audio_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Removes a user meta from a audio frame meta to which it is attached.\n\n @param[in] frame_meta    A pointer to the frame meta from which @a user_meta\n                          is to be removed.\n @param[in] user_meta     A pointer to the user meta to be removed from\n                          @a frame_meta."]
    pub fn nvds_remove_user_meta_from_audio_frame(
        frame_meta: *mut NvDsAudioFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " @brief  Copies or transforms meta data from one buffer to another.\n\n @param[in] data      A pointer to a batch meta (of type @ref NvDsBatchMeta),\n                      cast to @c gpointer.\n @param[in] user_data Currently not in use and should be set to NULL.\n\n @return A pointer to a metadata structure, to be cast to type NvDsBatchMeta."]
    pub fn nvds_audio_batch_meta_copy_func(data: gpointer, user_data: gpointer) -> gpointer;
}
extern "C" {
    #[doc = " Releases metadata from a batch meta.\n\n @param[in] data      A pointer to a batch meta (type @ref NvDsBatchMeta),\n                      cast to @c gpointer.\n @param[in] user_data Currently not in use and should be set to NULL."]
    pub fn nvds_audio_batch_meta_release_func(data: gpointer, user_data: gpointer);
}
extern "C" {
    #[doc = " Returns a pointer to a specified frame meta in the frame meta list.\n\n @param[in] frame_meta_list   A pointer to a list of pointers to frame metas.\n @param[in] index             The index of the frame meta to be returned.\n\n @return  A pointer to the @a index'th frame meta in the frame meta list."]
    pub fn nvds_get_nth_audio_frame_meta(
        frame_meta_list: *mut NvDsFrameMetaList,
        index: guint,
    ) -> *mut NvDsAudioFrameMeta;
}
extern "C" {
    #[doc = " Removes all of the frame metadata attached to a batch meta.\n\n @param[in] batch_meta    A pointer to the batch whose frame meta list\n                          is to be cleared.\n @param[in] meta_list     A pointer to the frame meta list to be cleared."]
    pub fn nvds_clear_audio_frame_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsFrameMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the classifier metadata attached to an audio frame meta.\n\n @param[in] frame_meta A pointer to @ref NvDsAudioFrameMeta from which @a\n            NvDsClassifierMetaList needs to be cleared\n @param[in] meta_list A pointer to @ref NvDsClassifierMetaList which needs to\n            be cleared"]
    pub fn nvds_clear_audio_classifier_meta_list(
        frame_meta: *mut NvDsAudioFrameMeta,
        meta_list: *mut NvDsClassifierMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to the audio batch meta.\n\n @param[in] batch_meta    A pointer to the audio batch meta whose\n                          user meta list is to be cleared.\n @param[in] meta_list     A pointer to the user meta list to be\n            cleared"]
    pub fn nvds_clear_audio_batch_user_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to the audio frame meta.\n\n @param[in] frame_meta    A pointer to the audio frame meta whose\n                          user meta list is to be cleared.\n @param[in] meta_list     A pointer to the user meta list to be cleared."]
    pub fn nvds_clear_audio_frame_user_meta_list(
        frame_meta: *mut NvDsAudioFrameMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a user meta list to the user meta list\n in a specified audio batch meta.\n\n @param[in] src_user_meta_list    A pointer to the source user meta list.\n @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_audio_batch_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a frame meta to another frame meta.\n\n @param[in] src_frame_meta    A pointer to the source frame meta.\n @param[in] dst_frame_meta    A pointer to the destination frame meta."]
    pub fn nvds_copy_audio_frame_meta(
        src_frame_meta: *mut NvDsAudioFrameMeta,
        dst_frame_meta: *mut NvDsAudioFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source user meta list to the user meta list\n in a specified audio frame meta.\n\n @param[in] src_user_meta_list    A pointer to the source user meta list.\n @param[in] dst_frame_meta        A pointer to the destination audio frame meta."]
    pub fn nvds_copy_audio_frame_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_frame_meta: *mut NvDsAudioFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source frame meta list to the frame meta list\n  in a specified batch meta.\n\n @param[in] src_frame_meta_list   A pointer to the source frame meta list.\n @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_audio_frame_meta_list(
        src_frame_meta_list: *mut NvDsFrameMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source classifier meta list to the\n  classifier meta list in a specified object meta.\n\n @param[in] src_classifier_meta_list  A pointer to the source\n                                      classifier meta list.\n @param[in] dst_frame_meta           A pointer to the destination\n                                      audio frame meta."]
    pub fn nvds_copy_audio_classification_list(
        src_classifier_meta_list: *mut NvDsClassifierMetaList,
        dst_frame_meta: *mut NvDsAudioFrameMeta,
    );
}
#[doc = " Holds information about latency of the given subcomponent"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsMetaSubCompLatency {
    #[doc = " Holds the subcomponent names."]
    pub sub_comp_name: [gchar; 64usize],
    #[doc = " Holds the system timestamp of the buffer when it arrives\nat the input of the component."]
    pub in_system_timestamp: gdouble,
    #[doc = " Holds the system timestamp of the buffer when it leaves\nat the output of the component."]
    pub out_system_timestamp: gdouble,
}
#[test]
fn bindgen_test_layout__NvDsMetaSubCompLatency() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsMetaSubCompLatency> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsMetaSubCompLatency>(),
        80usize,
        concat!("Size of: ", stringify!(_NvDsMetaSubCompLatency))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsMetaSubCompLatency>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsMetaSubCompLatency))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sub_comp_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaSubCompLatency),
            "::",
            stringify!(sub_comp_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_system_timestamp) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaSubCompLatency),
            "::",
            stringify!(in_system_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_system_timestamp) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaSubCompLatency),
            "::",
            stringify!(out_system_timestamp)
        )
    );
}
#[doc = " Holds information about latency of the given subcomponent"]
pub type NvDsMetaSubCompLatency = _NvDsMetaSubCompLatency;
#[doc = " Holds information about latency of the given component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsMetaCompLatency {
    #[doc = " Holds the name of the component for which latency is measured."]
    pub component_name: [gchar; 64usize],
    #[doc = " Holds the system timestamp of the buffer when it arrives\nat the input of the component."]
    pub in_system_timestamp: gdouble,
    #[doc = " Holds the system timestamp of buffer when it\nis sent to the downstream component."]
    pub out_system_timestamp: gdouble,
    #[doc = " Holds the source ID of the component, e.g. the camera ID."]
    pub source_id: guint,
    #[doc = " Holds the current frame number for which latency is measured."]
    pub frame_num: guint,
    #[doc = " Holds the pad or port index of the stream muxer for the frame\nin the batch."]
    pub pad_index: guint,
    #[doc = " Holds latency information of subcomponent in an array"]
    pub sub_comp_latencies: [NvDsMetaSubCompLatency; 16usize],
    #[doc = " Holds the number of subcomponents for the given component"]
    pub num_sub_comps: guint,
}
#[test]
fn bindgen_test_layout__NvDsMetaCompLatency() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsMetaCompLatency> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsMetaCompLatency>(),
        1384usize,
        concat!("Size of: ", stringify!(_NvDsMetaCompLatency))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsMetaCompLatency>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsMetaCompLatency))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).component_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaCompLatency),
            "::",
            stringify!(component_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_system_timestamp) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaCompLatency),
            "::",
            stringify!(in_system_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_system_timestamp) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaCompLatency),
            "::",
            stringify!(out_system_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaCompLatency),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_num) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaCompLatency),
            "::",
            stringify!(frame_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad_index) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaCompLatency),
            "::",
            stringify!(pad_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sub_comp_latencies) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaCompLatency),
            "::",
            stringify!(sub_comp_latencies)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_sub_comps) as usize - ptr as usize },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaCompLatency),
            "::",
            stringify!(num_sub_comps)
        )
    );
}
#[doc = " Holds information about latency of the given component"]
pub type NvDsMetaCompLatency = _NvDsMetaCompLatency;
#[doc = " Holds information about the latency of a given frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsFrameLatencyInfo {
    #[doc = " Holds the source ID of the component, e.g. the camera ID."]
    pub source_id: guint,
    #[doc = " Holds the current frame number for which latency is measured."]
    pub frame_num: guint,
    #[doc = " Holds the system timestamp of the buffer when it arrives\nat the input of the first component in the pipeline. By default,\nthe decoder is considered to be the first component in the pipeline."]
    pub comp_in_timestamp: gdouble,
    #[doc = " Holds the latency of the frame in milliseconds."]
    pub latency: gdouble,
}
#[test]
fn bindgen_test_layout_NvDsFrameLatencyInfo() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsFrameLatencyInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsFrameLatencyInfo>(),
        24usize,
        concat!("Size of: ", stringify!(NvDsFrameLatencyInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsFrameLatencyInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsFrameLatencyInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsFrameLatencyInfo),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_num) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsFrameLatencyInfo),
            "::",
            stringify!(frame_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comp_in_timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsFrameLatencyInfo),
            "::",
            stringify!(comp_in_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latency) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsFrameLatencyInfo),
            "::",
            stringify!(latency)
        )
    );
}
extern "C" {
    #[doc = " Sets the system timestamp when the Gst Buffer arrives as input at the\n component.\n\n @param[in] buffer        A pointer to the arriving Gst Buffer.\n @param[in] element_name  A pointer to the name of the component for which\n                          latency is to be measured.\n\n @returns  A pointer to a @ref NvDsUserMeta structure which holds an\n          @ref NvDsMetaCompLatency as @a NvDsUserMeta.user_meta_data."]
    pub fn nvds_set_input_system_timestamp(
        buffer: *mut GstBuffer,
        element_name: *mut gchar,
    ) -> *mut NvDsUserMeta;
}
extern "C" {
    #[doc = " \\brief  Sets the system timestamp when a Gst Buffer that is pushed\n  to the downstream component.\n\n This is a corresponding function to nvds_set_input_system_timestamp().\n\n @param[in] buffer        A pointer to a Gst Buffer to be pushed\n                          to the downstream component.\n @param[in] element_name  A pointer to the name of the component for which\n                          latency is to be measured.\n\n @returns  TRUE if the timestamp is attached successfully, or FALSE otherwise."]
    pub fn nvds_set_output_system_timestamp(
        buffer: *mut GstBuffer,
        element_name: *mut gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " \\brief  Measures the latency of all frames present in the current batch.\n\n The latency is computed from decoder input up to the point this API is called.\n You can install the probe on either pad of the component and call\n this function to measure the latency.\n\n @param[in]  buf          A pointer to a Gst Buffer to which\n                          @ref NvDsBatchMeta is attached as metadata.\n @param[out] latency_info A pointer to an NvDsFrameLatencyInfo structure\n                          allocated for a batch of this size. The function\n                          fills it with information about all of the sources."]
    pub fn nvds_measure_buffer_latency(
        buf: *mut GstBuffer,
        latency_info: *mut NvDsFrameLatencyInfo,
    ) -> guint;
}
extern "C" {
    #[doc = " Indicates whether the environment variable\n @c NVDS_ENABLE_LATENCY_MEASUREMENT is exported.\n\n @returns  True if the environment variable is exported, or false otherwise."]
    pub fn nvds_get_enable_latency_measurement() -> gboolean;
}
extern "C" {
    #[doc = " Adds the reference timestamp metadata for this buffer\n Note: element_name == \"audiodecoder\" and \"nvv4l2decoder\" will be used for\n latency measurement calculations where the timestamp will be used\n by API: nvds_measure_buffer_latency()\n to calculate the latency of buffers downstream relative to the decoder.\n\n @param[in] buffer        A pointer to the arriving Gst Buffer.\n @param[in] element_name  A pointer to the name of the component for which\n                          latency is to be measured.\n @param[in] frame_id      The id/number of this frame/buffer produced by\n                          the component that produces this buffer.\n"]
    pub fn nvds_add_reference_timestamp_meta(
        buffer: *mut GstBuffer,
        element_name: *mut gchar,
        frame_id: guint,
    );
}
extern "C" {
    pub fn nvds_meta_api_get_type() -> GType;
}
extern "C" {
    pub fn nvds_meta_get_info() -> *const GstMetaInfo;
}
#[doc = " Holds DeepSteam metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsMeta {
    pub meta: GstMeta,
    #[doc = " Holds a pointer to metadata. Must be cast to another structure based\non @a meta_type."]
    pub meta_data: gpointer,
    #[doc = " Holds a pointer to user-specific data ."]
    pub user_data: gpointer,
    #[doc = " Holds the type of metadata, one of values of enum @ref GstNvDsMetaType."]
    pub meta_type: gint,
    #[doc = " A callback to be called when @a meta_data is to be copied or transformed\nfrom one buffer to other. @a meta_data and @a user_data are passed\nas arguments."]
    pub copyfunc: NvDsMetaCopyFunc,
    #[doc = " A callback to be called when @a meta_data is to be destroyed.\n@a meta_data and @a user_data are passed as arguments."]
    pub freefunc: NvDsMetaReleaseFunc,
    #[doc = " A callback to be called when @a meta_data is transformed into\n @a NvDsUserMeta.\n This function must be provided by a GStreamer plugin that precedes\n @a Gst-nvstreammux in the DeepStream pipeline.\n Gst-nvstreammux copies @a meta_data to\n user meta data at frame level inside @ref NvDsFrameMeta.\n @a meta_data and @a user_data are passed as arguments.\n\n To retrive the content of @a meta_data, iterate over\n @ref NvDsFrameMetaList. Then search for @a meta_type of @ref NvDsUserMeta\n which the user has attached. (See deepstream-gst-metadata-test source\n code for more details.)\n\n @a meta_data and @a user_data are passed as arguments."]
    pub gst_to_nvds_meta_transform_func: NvDsMetaCopyFunc,
    #[doc = " A callback to be called when @a meta_data transformed into\n @a NvDsUserMeta is to be destroyed.\n This function must be provided by a GStreamer plugin that precedes\n @a Gst-nvstreammux in the DeepStream pipeline."]
    pub gst_to_nvds_meta_release_func: NvDsMetaReleaseFunc,
}
#[test]
fn bindgen_test_layout__NvDsMeta() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsMeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsMeta>(),
        72usize,
        concat!("Size of: ", stringify!(_NvDsMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(meta_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(meta_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyfunc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(copyfunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freefunc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(freefunc)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).gst_to_nvds_meta_transform_func) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(gst_to_nvds_meta_transform_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).gst_to_nvds_meta_release_func) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(gst_to_nvds_meta_release_func)
        )
    );
}
#[doc = " Holds DeepSteam metadata."]
pub type NvDsMeta = _NvDsMeta;
extern "C" {
    #[doc = " Adds %GstMeta of type @ref NvDsMeta to the GstBuffer and sets the @a meta_data\n member of @ref NvDsMeta.\n\n @param[in] buffer    A pointer to a %GstBuffer to which the function adds\n                      metadata.\n @param[in] meta_data A pointer at which the function sets the @a meta_data\n                      member of @ref NvDsMeta.\n @param[in] user_data A pointer to the user-specific data.\n @param[in] copy_func The callback to be called when\n                      NvDsMeta is to be copied. The function is called with\n                      @a meta_data and @a user_data as parameters.\n @param[in] release_func\n                      The callback to be called when\n                      NvDsMeta is to be destroyed. The function is called with\n                      @a meta_data and @a user_data as parameters.\n\n @return  A pointer to the attached NvDsMeta structure if successful,\n  or NULL otherwise."]
    pub fn gst_buffer_add_nvds_meta(
        buffer: *mut GstBuffer,
        meta_data: gpointer,
        user_data: gpointer,
        copy_func: NvDsMetaCopyFunc,
        release_func: NvDsMetaReleaseFunc,
    ) -> *mut NvDsMeta;
}
extern "C" {
    #[doc = " Gets the @ref NvDsMeta last added to a GstBuffer.\n\n @param[in] buffer    A pointer to the GstBuffer.\n\n @return  A pointer to the last added NvDsMeta structure, or NULL if no\n          %NvDsMeta was attached."]
    pub fn gst_buffer_get_nvds_meta(buffer: *mut GstBuffer) -> *mut NvDsMeta;
}
extern "C" {
    #[doc = " Gets the @ref NvDsBatchMeta added to a GstBuffer.\n\n @param[in] buffer    A pointer to the GstBuffer.\n\n @return  A pointer to the NvDsBatchMeta structure, or NULL if no\n          NvDsMeta was attached."]
    pub fn gst_buffer_get_nvds_batch_meta(buffer: *mut GstBuffer) -> *mut NvDsBatchMeta;
}
extern "C" {
    #[doc = " Copies all GstMeta objects on src_gst_buffer to\n the batched buffer's @ref NvDsBatchMeta\n The GstMeta objects are copied into the user_meta_list\n within @ref NvDsFrameMeta.\n\n Note: the list of plain GstMeta from @src_gst_buffer are copied into\n @frame_meta as a single frame_meta->user_meta\n with NvDsUserMeta->base_meta.meta_type == @ref NVDS_USER_FRAME_META_GST_META.\n The list of N X NvDsMeta from @src_gst_buffer are copied into\n @frame_meta as N X frame_meta->user_meta\n with each NvDsUserMeta->base_meta.meta_type == NvDsMeta->meta_type.\n\n @param[in] src_gst_buffer    A pointer to the GstBuffer.\n                              GstMeta objects in this GstBuffer\n                              will be copied.\n @param[in] batch_meta        A pointer to the @ref NvDsBatchMeta obtained\n                              from nvstreammux plugin. (Note: Works only\n                              for nvstreammux2 (Beta))\n @param[in] frame_meta        A pointer to the @ref NvDsFrameMeta\n                              @ref NvDsFrameMeta (metadata) for\n                              the batched input frame to which GstMeta objects\n                              will be copied as frame @ref NvDsUserMeta.\n"]
    pub fn nvds_copy_gst_meta_to_frame_meta(
        src_gst_buffer: *mut GstBuffer,
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " Copies all GstMeta objects on src_gst_buffer to\n the batched buffer's @ref NvDsBatchMeta\n The GstMeta objects are copied into the user_meta_list\n within @ref NvDsAudioFrameMeta.\n\n Note: the list of plain GstMeta from @src_gst_buffer are copied into\n @frame_meta as a single frame_meta->user_meta\n with NvDsUserMeta->base_meta.meta_type == @ref NVDS_USER_FRAME_META_GST_META.\n The list of N X NvDsMeta from @src_gst_buffer are copied into\n @frame_meta as N X frame_meta->user_meta\n with each NvDsUserMeta->base_meta.meta_type == NvDsMeta->meta_type.\n\n @param[in] src_gst_buffer    A pointer to the GstBuffer.\n                              GstMeta objects in this GstBuffer\n                              will be copied.\n @param[in] batch_meta        A pointer to the @ref NvDsBatchMeta obtained\n                              from nvstreammux plugin. (Note: Works only\n                              for nvstreammux2 (Beta))\n @param[in] frame_meta        A pointer to the @ref NvDsAudioFrameMeta\n                              @ref NvDsAudioFrameMeta (metadata) for\n                              the batched input frame to which GstMeta objects\n                              will be copied as frame @ref NvDsUserMeta.\n"]
    pub fn nvds_copy_gst_meta_to_audio_frame_meta(
        src_gst_buffer: *mut GstBuffer,
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsAudioFrameMeta,
    );
}
#[doc = " Holds the dimensions of a layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferDims {
    #[doc = " Holds the number of dimesions in the layer."]
    pub numDims: ::std::os::raw::c_uint,
    #[doc = " Holds the size of the layer in each dimension."]
    pub d: [::std::os::raw::c_uint; 8usize],
    #[doc = " Holds the number of elements in the layer, including all dimensions."]
    pub numElements: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_NvDsInferDims() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferDims> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferDims>(),
        40usize,
        concat!("Size of: ", stringify!(NvDsInferDims))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferDims>(),
        4usize,
        concat!("Alignment of ", stringify!(NvDsInferDims))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numDims) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDims),
            "::",
            stringify!(numDims)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDims),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numElements) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDims),
            "::",
            stringify!(numElements)
        )
    );
}
#[doc = " Holds the dimensions of a three-dimensional layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferDimsCHW {
    #[doc = " Holds the channel count of the layer."]
    pub c: ::std::os::raw::c_uint,
    #[doc = " Holds the height of the layer."]
    pub h: ::std::os::raw::c_uint,
    #[doc = " Holds the width of the layer."]
    pub w: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_NvDsInferDimsCHW() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferDimsCHW> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferDimsCHW>(),
        12usize,
        concat!("Size of: ", stringify!(NvDsInferDimsCHW))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferDimsCHW>(),
        4usize,
        concat!("Alignment of ", stringify!(NvDsInferDimsCHW))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDimsCHW),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDimsCHW),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDimsCHW),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " Specifies FP32 format."]
pub const NvDsInferDataType_FLOAT: NvDsInferDataType = 0;
#[doc = " Specifies FP16 format."]
pub const NvDsInferDataType_HALF: NvDsInferDataType = 1;
#[doc = " Specifies INT8 format."]
pub const NvDsInferDataType_INT8: NvDsInferDataType = 2;
#[doc = " Specifies INT32 format."]
pub const NvDsInferDataType_INT32: NvDsInferDataType = 3;
#[doc = " Specifies the data type of a layer."]
pub type NvDsInferDataType = ::std::os::raw::c_uint;
#[doc = " Holds information about one layer in the model."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvDsInferLayerInfo {
    #[doc = " Holds the data type of the layer."]
    pub dataType: NvDsInferDataType,
    pub __bindgen_anon_1: NvDsInferLayerInfo__bindgen_ty_1,
    #[doc = " Holds the TensorRT binding index of the layer."]
    pub bindingIndex: ::std::os::raw::c_int,
    #[doc = " Holds the name of the layer."]
    pub layerName: *const ::std::os::raw::c_char,
    #[doc = " Holds a pointer to the buffer for the layer data."]
    pub buffer: *mut ::std::os::raw::c_void,
    #[doc = " Holds a Boolean; true if the layer is an input layer,\nor false if an output layer."]
    pub isInput: ::std::os::raw::c_int,
}
#[doc = " Holds the dimensions of the layer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union NvDsInferLayerInfo__bindgen_ty_1 {
    pub inferDims: NvDsInferDims,
    pub dims: NvDsInferDims,
}
#[test]
fn bindgen_test_layout_NvDsInferLayerInfo__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferLayerInfo__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferLayerInfo__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(NvDsInferLayerInfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferLayerInfo__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NvDsInferLayerInfo__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inferDims) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferLayerInfo__bindgen_ty_1),
            "::",
            stringify!(inferDims)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dims) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferLayerInfo__bindgen_ty_1),
            "::",
            stringify!(dims)
        )
    );
}
#[test]
fn bindgen_test_layout_NvDsInferLayerInfo() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferLayerInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferLayerInfo>(),
        72usize,
        concat!("Size of: ", stringify!(NvDsInferLayerInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferLayerInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsInferLayerInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferLayerInfo),
            "::",
            stringify!(dataType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bindingIndex) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferLayerInfo),
            "::",
            stringify!(bindingIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layerName) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferLayerInfo),
            "::",
            stringify!(layerName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferLayerInfo),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isInput) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferLayerInfo),
            "::",
            stringify!(isInput)
        )
    );
}
#[doc = " Holds information about the model network."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferNetworkInfo {
    #[doc = " Holds the input width for the model."]
    pub width: ::std::os::raw::c_uint,
    #[doc = " Holds the input height for the model."]
    pub height: ::std::os::raw::c_uint,
    #[doc = " Holds the number of input channels for the model."]
    pub channels: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_NvDsInferNetworkInfo() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferNetworkInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferNetworkInfo>(),
        12usize,
        concat!("Size of: ", stringify!(NvDsInferNetworkInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferNetworkInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(NvDsInferNetworkInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferNetworkInfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferNetworkInfo),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferNetworkInfo),
            "::",
            stringify!(channels)
        )
    );
}
#[doc = " Holds information about one parsed object from a detector's output."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferObjectDetectionInfo {
    #[doc = " Holds the ID of the class to which the object belongs."]
    pub classId: ::std::os::raw::c_uint,
    #[doc = " Holds the horizontal offset of the bounding box shape for the object."]
    pub left: f32,
    #[doc = " Holds the vertical offset of the object's bounding box."]
    pub top: f32,
    #[doc = " Holds the width of the object's bounding box."]
    pub width: f32,
    #[doc = " Holds the height of the object's bounding box."]
    pub height: f32,
    #[doc = " Holds the object detection confidence level; must in the range\n[0.0,1.0]."]
    pub detectionConfidence: f32,
}
#[test]
fn bindgen_test_layout_NvDsInferObjectDetectionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferObjectDetectionInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferObjectDetectionInfo>(),
        24usize,
        concat!("Size of: ", stringify!(NvDsInferObjectDetectionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferObjectDetectionInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(NvDsInferObjectDetectionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObjectDetectionInfo),
            "::",
            stringify!(classId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObjectDetectionInfo),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObjectDetectionInfo),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObjectDetectionInfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObjectDetectionInfo),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detectionConfidence) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObjectDetectionInfo),
            "::",
            stringify!(detectionConfidence)
        )
    );
}
#[doc = " A typedef defined to maintain backward compatibility."]
pub type NvDsInferParseObjectInfo = NvDsInferObjectDetectionInfo;
#[doc = " Holds information about one parsed object and instance mask from a detector's output."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferInstanceMaskInfo {
    #[doc = " Holds the ID of the class to which the object belongs."]
    pub classId: ::std::os::raw::c_uint,
    #[doc = " Holds the horizontal offset of the bounding box shape for the object."]
    pub left: f32,
    #[doc = " Holds the vertical offset of the object's bounding box."]
    pub top: f32,
    #[doc = " Holds the width of the object's bounding box."]
    pub width: f32,
    #[doc = " Holds the height of the object's bounding box."]
    pub height: f32,
    #[doc = " Holds the object detection confidence level; must in the range\n[0.0,1.0]."]
    pub detectionConfidence: f32,
    #[doc = " Holds object segment mask"]
    pub mask: *mut f32,
    #[doc = " Holds width of mask"]
    pub mask_width: ::std::os::raw::c_uint,
    #[doc = " Holds height of mask"]
    pub mask_height: ::std::os::raw::c_uint,
    #[doc = " Holds size of mask in bytes"]
    pub mask_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_NvDsInferInstanceMaskInfo() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferInstanceMaskInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferInstanceMaskInfo>(),
        48usize,
        concat!("Size of: ", stringify!(NvDsInferInstanceMaskInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferInstanceMaskInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsInferInstanceMaskInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferInstanceMaskInfo),
            "::",
            stringify!(classId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferInstanceMaskInfo),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferInstanceMaskInfo),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferInstanceMaskInfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferInstanceMaskInfo),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detectionConfidence) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferInstanceMaskInfo),
            "::",
            stringify!(detectionConfidence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferInstanceMaskInfo),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_width) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferInstanceMaskInfo),
            "::",
            stringify!(mask_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_height) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferInstanceMaskInfo),
            "::",
            stringify!(mask_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferInstanceMaskInfo),
            "::",
            stringify!(mask_size)
        )
    );
}
#[doc = " Holds information about one classified attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferAttribute {
    #[doc = " Holds the index of the attribute's label. This index corresponds to\nthe order of output layers specified in the @a outputCoverageLayerNames\nvector during initialization."]
    pub attributeIndex: ::std::os::raw::c_uint,
    #[doc = " Holds the the attribute's output value."]
    pub attributeValue: ::std::os::raw::c_uint,
    #[doc = " Holds the attribute's confidence level."]
    pub attributeConfidence: f32,
    #[doc = " Holds a pointer to a string containing the attribute's label.\nMemory for the string must not be freed. Custom parsing functions must\nallocate strings on heap using strdup or equivalent."]
    pub attributeLabel: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NvDsInferAttribute() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferAttribute> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferAttribute>(),
        24usize,
        concat!("Size of: ", stringify!(NvDsInferAttribute))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferAttribute>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsInferAttribute))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributeIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferAttribute),
            "::",
            stringify!(attributeIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributeValue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferAttribute),
            "::",
            stringify!(attributeValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributeConfidence) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferAttribute),
            "::",
            stringify!(attributeConfidence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributeLabel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferAttribute),
            "::",
            stringify!(attributeLabel)
        )
    );
}
#[doc = " NvDsInferContext operation succeeded."]
pub const NvDsInferStatus_NVDSINFER_SUCCESS: NvDsInferStatus = 0;
#[doc = " Failed to configure the NvDsInferContext instance possibly due to an\n  erroneous initialization property."]
pub const NvDsInferStatus_NVDSINFER_CONFIG_FAILED: NvDsInferStatus = 1;
#[doc = " Custom Library interface implementation failed."]
pub const NvDsInferStatus_NVDSINFER_CUSTOM_LIB_FAILED: NvDsInferStatus = 2;
#[doc = " Invalid parameters were supplied."]
pub const NvDsInferStatus_NVDSINFER_INVALID_PARAMS: NvDsInferStatus = 3;
#[doc = " Output parsing failed."]
pub const NvDsInferStatus_NVDSINFER_OUTPUT_PARSING_FAILED: NvDsInferStatus = 4;
#[doc = " CUDA error was encountered."]
pub const NvDsInferStatus_NVDSINFER_CUDA_ERROR: NvDsInferStatus = 5;
#[doc = " TensorRT interface failed."]
pub const NvDsInferStatus_NVDSINFER_TENSORRT_ERROR: NvDsInferStatus = 6;
#[doc = " Resource error was encountered."]
pub const NvDsInferStatus_NVDSINFER_RESOURCE_ERROR: NvDsInferStatus = 7;
#[doc = " Triton error was encountered. Renamed TRT-IS to Triton."]
pub const NvDsInferStatus_NVDSINFER_TRITON_ERROR: NvDsInferStatus = 8;
#[doc = " [deprecated]TRT-IS error was encountered"]
pub const NvDsInferStatus_NVDSINFER_TRTIS_ERROR: NvDsInferStatus = 8;
#[doc = " Unknown error was encountered."]
pub const NvDsInferStatus_NVDSINFER_UNKNOWN_ERROR: NvDsInferStatus = 9;
#[doc = " Enum for the status codes returned by NvDsInferContext."]
pub type NvDsInferStatus = ::std::os::raw::c_uint;
pub const NvDsInferLogLevel_NVDSINFER_LOG_ERROR: NvDsInferLogLevel = 0;
pub const NvDsInferLogLevel_NVDSINFER_LOG_WARNING: NvDsInferLogLevel = 1;
pub const NvDsInferLogLevel_NVDSINFER_LOG_INFO: NvDsInferLogLevel = 2;
pub const NvDsInferLogLevel_NVDSINFER_LOG_DEBUG: NvDsInferLogLevel = 3;
#[doc = " Enum for the log levels of NvDsInferContext."]
pub type NvDsInferLogLevel = ::std::os::raw::c_uint;
#[doc = "< Specifies \\ref NvBufSurface mapping type \"read.\""]
pub const NvBufSurfaceMemMapFlags_NVBUF_MAP_READ: NvBufSurfaceMemMapFlags = 0;
#[doc = "< Specifies \\ref NvBufSurface mapping type\n\"write.\""]
pub const NvBufSurfaceMemMapFlags_NVBUF_MAP_WRITE: NvBufSurfaceMemMapFlags = 1;
#[doc = "< Specifies \\ref NvBufSurface mapping type\n\"read/write.\""]
pub const NvBufSurfaceMemMapFlags_NVBUF_MAP_READ_WRITE: NvBufSurfaceMemMapFlags = 2;
#[doc = "  Defines mapping types of NvBufSurface."]
pub type NvBufSurfaceMemMapFlags = ::std::os::raw::c_uint;
#[doc = " tag None."]
pub const NvBufSurfaceTag_NvBufSurfaceTag_NONE: NvBufSurfaceTag = 0;
#[doc = " tag for Camera."]
pub const NvBufSurfaceTag_NvBufSurfaceTag_CAMERA: NvBufSurfaceTag = 512;
#[doc = " tag for Jpeg Encoder/Decoder."]
pub const NvBufSurfaceTag_NvBufSurfaceTag_JPEG: NvBufSurfaceTag = 5376;
#[doc = " tag for VPR Buffers."]
pub const NvBufSurfaceTag_NvBufSurfaceTag_PROTECTED: NvBufSurfaceTag = 5380;
#[doc = " tag for H264/H265 Video Encoder."]
pub const NvBufSurfaceTag_NvBufSurfaceTag_VIDEO_ENC: NvBufSurfaceTag = 4608;
#[doc = " tag for H264/H265/VP9 Video Decoder."]
pub const NvBufSurfaceTag_NvBufSurfaceTag_VIDEO_DEC: NvBufSurfaceTag = 5120;
#[doc = " tag for Video Transform/Composite/Blend."]
pub const NvBufSurfaceTag_NvBufSurfaceTag_VIDEO_CONVERT: NvBufSurfaceTag = 3841;
#[doc = " Defines tags that identify the components requesting a memory allocation.\n The tags can be used later to identify the total memory allocated to\n particular types of components.\n TODO: Check if DeepStream require more tags to be defined."]
pub type NvBufSurfaceTag = ::std::os::raw::c_uint;
#[doc = " Specifies an invalid color format."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_INVALID: NvBufSurfaceColorFormat = 0;
#[doc = " Specifies 8 bit GRAY scale - single plane"]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_GRAY8: NvBufSurfaceColorFormat = 1;
#[doc = " Specifies BT.601 colorspace - YUV420 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YUV420: NvBufSurfaceColorFormat = 2;
#[doc = " Specifies BT.601 colorspace - YUV420 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YVU420: NvBufSurfaceColorFormat = 3;
#[doc = " Specifies BT.601 colorspace - YUV420 ER multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YUV420_ER: NvBufSurfaceColorFormat = 4;
#[doc = " Specifies BT.601 colorspace - YVU420 ER multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YVU420_ER: NvBufSurfaceColorFormat = 5;
#[doc = " Specifies BT.601 colorspace - Y/CbCr 4:2:0 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV12: NvBufSurfaceColorFormat = 6;
#[doc = " Specifies BT.601 colorspace - Y/CbCr ER 4:2:0 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV12_ER: NvBufSurfaceColorFormat = 7;
#[doc = " Specifies BT.601 colorspace - Y/CbCr 4:2:0 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV21: NvBufSurfaceColorFormat = 8;
#[doc = " Specifies BT.601 colorspace - Y/CbCr ER 4:2:0 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV21_ER: NvBufSurfaceColorFormat = 9;
#[doc = " Specifies BT.601 colorspace - YUV 4:2:2 planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_UYVY: NvBufSurfaceColorFormat = 10;
#[doc = " Specifies BT.601 colorspace - YUV ER 4:2:2 planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_UYVY_ER: NvBufSurfaceColorFormat = 11;
#[doc = " Specifies BT.601 colorspace - YUV 4:2:2 planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_VYUY: NvBufSurfaceColorFormat = 12;
#[doc = " Specifies BT.601 colorspace - YUV ER 4:2:2 planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_VYUY_ER: NvBufSurfaceColorFormat = 13;
#[doc = " Specifies BT.601 colorspace - YUV 4:2:2 planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YUYV: NvBufSurfaceColorFormat = 14;
#[doc = " Specifies BT.601 colorspace - YUV ER 4:2:2 planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YUYV_ER: NvBufSurfaceColorFormat = 15;
#[doc = " Specifies BT.601 colorspace - YUV 4:2:2 planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YVYU: NvBufSurfaceColorFormat = 16;
#[doc = " Specifies BT.601 colorspace - YUV ER 4:2:2 planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YVYU_ER: NvBufSurfaceColorFormat = 17;
#[doc = " Specifies BT.601 colorspace - YUV444 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YUV444: NvBufSurfaceColorFormat = 18;
#[doc = " Specifies RGBA-8-8-8-8 single plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_RGBA: NvBufSurfaceColorFormat = 19;
#[doc = " Specifies BGRA-8-8-8-8 single plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_BGRA: NvBufSurfaceColorFormat = 20;
#[doc = " Specifies ARGB-8-8-8-8 single plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_ARGB: NvBufSurfaceColorFormat = 21;
#[doc = " Specifies ABGR-8-8-8-8 single plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_ABGR: NvBufSurfaceColorFormat = 22;
#[doc = " Specifies RGBx-8-8-8-8 single plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_RGBx: NvBufSurfaceColorFormat = 23;
#[doc = " Specifies BGRx-8-8-8-8 single plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_BGRx: NvBufSurfaceColorFormat = 24;
#[doc = " Specifies xRGB-8-8-8-8 single plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_xRGB: NvBufSurfaceColorFormat = 25;
#[doc = " Specifies xBGR-8-8-8-8 single plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_xBGR: NvBufSurfaceColorFormat = 26;
#[doc = " Specifies RGB-8-8-8 single plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_RGB: NvBufSurfaceColorFormat = 27;
#[doc = " Specifies BGR-8-8-8 single plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_BGR: NvBufSurfaceColorFormat = 28;
#[doc = " Specifies BT.601 colorspace - Y/CbCr 4:2:0 10-bit multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV12_10LE: NvBufSurfaceColorFormat = 29;
#[doc = " Specifies BT.601 colorspace - Y/CbCr 4:2:0 12-bit multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV12_12LE: NvBufSurfaceColorFormat = 30;
#[doc = " Specifies BT.709 colorspace - YUV420 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YUV420_709: NvBufSurfaceColorFormat = 31;
#[doc = " Specifies BT.709 colorspace - YUV420 ER multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YUV420_709_ER: NvBufSurfaceColorFormat = 32;
#[doc = " Specifies BT.709 colorspace - Y/CbCr 4:2:0 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV12_709: NvBufSurfaceColorFormat = 33;
#[doc = " Specifies BT.709 colorspace - Y/CbCr ER 4:2:0 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV12_709_ER: NvBufSurfaceColorFormat = 34;
#[doc = " Specifies BT.2020 colorspace - YUV420 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YUV420_2020: NvBufSurfaceColorFormat = 35;
#[doc = " Specifies BT.2020 colorspace - Y/CbCr 4:2:0 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV12_2020: NvBufSurfaceColorFormat = 36;
#[doc = " Specifies BT.601 colorspace - Y/CbCr ER 4:2:0 10-bit multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV12_10LE_ER: NvBufSurfaceColorFormat = 37;
#[doc = " Specifies BT.709 colorspace - Y/CbCr 4:2:0 10-bit multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV12_10LE_709: NvBufSurfaceColorFormat = 38;
#[doc = " Specifies BT.709 colorspace - Y/CbCr ER 4:2:0 10-bit multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV12_10LE_709_ER: NvBufSurfaceColorFormat = 39;
#[doc = " Specifies BT.2020 colorspace - Y/CbCr 4:2:0 10-bit multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV12_10LE_2020: NvBufSurfaceColorFormat = 40;
#[doc = " Specifies color format for packed 2 signed shorts"]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_SIGNED_R16G16: NvBufSurfaceColorFormat = 41;
#[doc = " Specifies RGB- unsigned 8 bit multiplanar plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_R8_G8_B8: NvBufSurfaceColorFormat = 42;
#[doc = " Specifies BGR- unsigned 8 bit multiplanar plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_B8_G8_R8: NvBufSurfaceColorFormat = 43;
#[doc = " Specifies RGB-32bit Floating point multiplanar plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_R32F_G32F_B32F: NvBufSurfaceColorFormat = 44;
#[doc = " Specifies BGR-32bit Floating point multiplanar plane."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_B32F_G32F_R32F: NvBufSurfaceColorFormat = 45;
#[doc = " Specifies BT.601 colorspace - YUV422 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_YUV422: NvBufSurfaceColorFormat = 46;
#[doc = " Specifies BT.601 colorspace - Y/CrCb 4:2:0 10-bit multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV21_10LE: NvBufSurfaceColorFormat = 47;
#[doc = " Specifies BT.601 colorspace - Y/CrCb 4:2:0 12-bit multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV21_12LE: NvBufSurfaceColorFormat = 48;
#[doc = " Specifies BT.2020 colorspace - Y/CbCr 4:2:0 12-bit multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV12_12LE_2020: NvBufSurfaceColorFormat = 49;
#[doc = " Specifies BT.601 colorspace - Y/CbCr 4:2:2 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV16: NvBufSurfaceColorFormat = 50;
#[doc = " Specifies BT.601 colorspace - Y/CbCr 4:2:2 10-bit semi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV16_10LE: NvBufSurfaceColorFormat = 51;
#[doc = " Specifies BT.601 colorspace - Y/CbCr 4:4:4 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV24: NvBufSurfaceColorFormat = 52;
#[doc = " Specifies BT.601 colorspace - Y/CrCb 4:4:4 10-bit multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV24_10LE: NvBufSurfaceColorFormat = 53;
#[doc = " Specifies BT.601_ER colorspace - Y/CbCr 4:2:2 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV16_ER: NvBufSurfaceColorFormat = 54;
#[doc = " Specifies BT.601_ER colorspace - Y/CbCr 4:4:4 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV24_ER: NvBufSurfaceColorFormat = 55;
#[doc = " Specifies BT.709 colorspace - Y/CbCr 4:2:2 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV16_709: NvBufSurfaceColorFormat = 56;
#[doc = " Specifies BT.709 colorspace - Y/CbCr 4:4:4 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV24_709: NvBufSurfaceColorFormat = 57;
#[doc = " Specifies BT.709_ER colorspace - Y/CbCr 4:2:2 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV16_709_ER: NvBufSurfaceColorFormat = 58;
#[doc = " Specifies BT.709_ER colorspace - Y/CbCr 4:4:4 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV24_709_ER: NvBufSurfaceColorFormat = 59;
#[doc = " Specifies BT.709 colorspace - Y/CbCr 10 bit 4:4:4 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV24_10LE_709: NvBufSurfaceColorFormat = 60;
#[doc = " Specifies BT.709 ER colorspace - Y/CbCr 10 bit 4:4:4 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV24_10LE_709_ER: NvBufSurfaceColorFormat = 61;
#[doc = " Specifies BT.2020 colorspace - Y/CbCr 10 bit 4:4:4 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV24_10LE_2020: NvBufSurfaceColorFormat = 62;
#[doc = " Specifies BT.2020 colorspace - Y/CbCr 12 bit 4:4:4 multi-planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_NV24_12LE_2020: NvBufSurfaceColorFormat = 63;
#[doc = " Specifies Non-linear RGB BT.709 colorspace - RGBA-10-10-10-2 planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_RGBA_10_10_10_2_709: NvBufSurfaceColorFormat =
    64;
#[doc = " Specifies Non-linear RGB BT.2020 colorspace - RGBA-10-10-10-2 planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_RGBA_10_10_10_2_2020: NvBufSurfaceColorFormat =
    65;
#[doc = " Specifies Non-linear RGB BT.709 colorspace - BGRA-10-10-10-2 planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_BGRA_10_10_10_2_709: NvBufSurfaceColorFormat =
    66;
#[doc = " Specifies Non-linear RGB BT.2020 colorspace - BGRA-10-10-10-2 planar."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_BGRA_10_10_10_2_2020: NvBufSurfaceColorFormat =
    67;
#[doc = " Specifies Optical flow SAD calculation Buffer format"]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_A32: NvBufSurfaceColorFormat = 68;
#[doc = " Specifies BT.601 colorspace - 10 bit YUV 4:2:2 interleaved."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_UYVP: NvBufSurfaceColorFormat = 69;
#[doc = " Specifies BT.601 colorspace - 10 bit YUV ER 4:2:2 interleaved."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_UYVP_ER: NvBufSurfaceColorFormat = 70;
#[doc = " Specifies BT.601 colorspace - 10 bit YUV ER 4:2:2 interleaved."]
pub const NvBufSurfaceColorFormat_NVBUF_COLOR_FORMAT_LAST: NvBufSurfaceColorFormat = 71;
#[doc = " Defines color formats for NvBufSurface."]
pub type NvBufSurfaceColorFormat = ::std::os::raw::c_uint;
#[doc = " Specifies pitch layout."]
pub const NvBufSurfaceLayout_NVBUF_LAYOUT_PITCH: NvBufSurfaceLayout = 0;
#[doc = " Specifies block linear layout."]
pub const NvBufSurfaceLayout_NVBUF_LAYOUT_BLOCK_LINEAR: NvBufSurfaceLayout = 1;
#[doc = " Specifies layout formats for \\ref NvBufSurface video planes."]
pub type NvBufSurfaceLayout = ::std::os::raw::c_uint;
#[doc = " Specifies the default memory type, i.e. \\ref NVBUF_MEM_CUDA_DEVICE\nfor dGPU, \\ref NVBUF_MEM_SURFACE_ARRAY for Jetson. Use \\ref NVBUF_MEM_DEFAULT\nto allocate whichever type of memory is appropriate for the platform."]
pub const NvBufSurfaceMemType_NVBUF_MEM_DEFAULT: NvBufSurfaceMemType = 0;
#[doc = " Specifies CUDA Host memory type."]
pub const NvBufSurfaceMemType_NVBUF_MEM_CUDA_PINNED: NvBufSurfaceMemType = 1;
#[doc = " Specifies CUDA Device memory type."]
pub const NvBufSurfaceMemType_NVBUF_MEM_CUDA_DEVICE: NvBufSurfaceMemType = 2;
#[doc = " Specifies CUDA Unified memory type."]
pub const NvBufSurfaceMemType_NVBUF_MEM_CUDA_UNIFIED: NvBufSurfaceMemType = 3;
#[doc = " Specifies NVRM Surface Array type. Valid only for Jetson."]
pub const NvBufSurfaceMemType_NVBUF_MEM_SURFACE_ARRAY: NvBufSurfaceMemType = 4;
#[doc = " Specifies NVRM Handle type. Valid only for Jetson."]
pub const NvBufSurfaceMemType_NVBUF_MEM_HANDLE: NvBufSurfaceMemType = 5;
#[doc = " Specifies memory allocated by malloc()."]
pub const NvBufSurfaceMemType_NVBUF_MEM_SYSTEM: NvBufSurfaceMemType = 6;
#[doc = " Specifies memory types for \\ref NvBufSurface."]
pub type NvBufSurfaceMemType = ::std::os::raw::c_uint;
#[doc = " Progessive scan formats."]
pub const NvBufSurfaceDisplayScanFormat_NVBUF_DISPLAYSCANFORMAT_PROGRESSIVE:
    NvBufSurfaceDisplayScanFormat = 0;
#[doc = " Interlaced scan formats."]
pub const NvBufSurfaceDisplayScanFormat_NVBUF_DISPLAYSCANFORMAT_INTERLACED:
    NvBufSurfaceDisplayScanFormat = 1;
#[doc = " Defines display scan formats for NvBufSurface video planes."]
pub type NvBufSurfaceDisplayScanFormat = ::std::os::raw::c_uint;
#[doc = " Holds plane wise parameters(extended) of a buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufSurfacePlaneParamsEx {
    #[doc = " display scan format - progressive/interlaced."]
    pub scanformat: [NvBufSurfaceDisplayScanFormat; 4usize],
    #[doc = " offset of the second field for interlaced buffer."]
    pub secondfieldoffset: [u32; 4usize],
    #[doc = " block height of the planes for blockLinear layout buffer."]
    pub blockheightlog2: [u32; 4usize],
    #[doc = " physical address of allocated planes."]
    pub physicaladdress: [u32; 4usize],
    #[doc = " flags associated with planes"]
    pub flags: [u64; 4usize],
    pub _reserved: [*mut ::std::os::raw::c_void; 16usize],
}
#[test]
fn bindgen_test_layout_NvBufSurfacePlaneParamsEx() {
    const UNINIT: ::std::mem::MaybeUninit<NvBufSurfacePlaneParamsEx> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvBufSurfacePlaneParamsEx>(),
        224usize,
        concat!("Size of: ", stringify!(NvBufSurfacePlaneParamsEx))
    );
    assert_eq!(
        ::std::mem::align_of::<NvBufSurfacePlaneParamsEx>(),
        8usize,
        concat!("Alignment of ", stringify!(NvBufSurfacePlaneParamsEx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scanformat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParamsEx),
            "::",
            stringify!(scanformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secondfieldoffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParamsEx),
            "::",
            stringify!(secondfieldoffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockheightlog2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParamsEx),
            "::",
            stringify!(blockheightlog2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physicaladdress) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParamsEx),
            "::",
            stringify!(physicaladdress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParamsEx),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParamsEx),
            "::",
            stringify!(_reserved)
        )
    );
}
#[doc = " Holds plane wise parameters of a buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufSurfacePlaneParams {
    #[doc = " Holds the number of planes."]
    pub num_planes: u32,
    #[doc = " Holds the widths of planes."]
    pub width: [u32; 4usize],
    #[doc = " Holds the heights of planes."]
    pub height: [u32; 4usize],
    #[doc = " Holds the pitches of planes in bytes."]
    pub pitch: [u32; 4usize],
    #[doc = " Holds the offsets of planes in bytes."]
    pub offset: [u32; 4usize],
    #[doc = " Holds the sizes of planes in bytes."]
    pub psize: [u32; 4usize],
    #[doc = " Holds the number of bytes occupied by a pixel in each plane."]
    pub bytesPerPix: [u32; 4usize],
    pub _reserved: [*mut ::std::os::raw::c_void; 16usize],
}
#[test]
fn bindgen_test_layout_NvBufSurfacePlaneParams() {
    const UNINIT: ::std::mem::MaybeUninit<NvBufSurfacePlaneParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvBufSurfacePlaneParams>(),
        232usize,
        concat!("Size of: ", stringify!(NvBufSurfacePlaneParams))
    );
    assert_eq!(
        ::std::mem::align_of::<NvBufSurfacePlaneParams>(),
        8usize,
        concat!("Alignment of ", stringify!(NvBufSurfacePlaneParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_planes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParams),
            "::",
            stringify!(num_planes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParams),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParams),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParams),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParams),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psize) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParams),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesPerPix) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParams),
            "::",
            stringify!(bytesPerPix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfacePlaneParams),
            "::",
            stringify!(_reserved)
        )
    );
}
#[doc = " Holds Chroma Subsampling parameters for NvBufSurface allocation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufSurfaceChromaSubsamplingParams {
    #[doc = " location settings"]
    pub chromaLocHoriz: u8,
    pub chromaLocVert: u8,
}
#[test]
fn bindgen_test_layout_NvBufSurfaceChromaSubsamplingParams() {
    const UNINIT: ::std::mem::MaybeUninit<NvBufSurfaceChromaSubsamplingParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvBufSurfaceChromaSubsamplingParams>(),
        2usize,
        concat!("Size of: ", stringify!(NvBufSurfaceChromaSubsamplingParams))
    );
    assert_eq!(
        ::std::mem::align_of::<NvBufSurfaceChromaSubsamplingParams>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(NvBufSurfaceChromaSubsamplingParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chromaLocHoriz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceChromaSubsamplingParams),
            "::",
            stringify!(chromaLocHoriz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chromaLocVert) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceChromaSubsamplingParams),
            "::",
            stringify!(chromaLocVert)
        )
    );
}
#[doc = " Holds parameters required to allocate an \\ref NvBufSurface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufSurfaceCreateParams {
    #[doc = " Holds the GPU ID. Valid only for a multi-GPU system."]
    pub gpuId: u32,
    #[doc = " Holds the width of the buffer."]
    pub width: u32,
    #[doc = " Holds the height of the buffer."]
    pub height: u32,
    #[doc = " Holds the amount of memory to be allocated. Optional; if set, all other\nparameters (width, height, etc.) are ignored."]
    pub size: u32,
    #[doc = " Holds a \"contiguous memory\" flag. If set, contiguous memory is allocated\nfor the batch. Valid only for CUDA memory types."]
    pub isContiguous: bool,
    #[doc = " Holds the color format of the buffer."]
    pub colorFormat: NvBufSurfaceColorFormat,
    #[doc = " Holds the surface layout. May be Block Linear (BL) or Pitch Linear (PL).\nFor a dGPU, only PL is valid."]
    pub layout: NvBufSurfaceLayout,
    #[doc = " Holds the type of memory to be allocated."]
    pub memType: NvBufSurfaceMemType,
}
#[test]
fn bindgen_test_layout_NvBufSurfaceCreateParams() {
    const UNINIT: ::std::mem::MaybeUninit<NvBufSurfaceCreateParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvBufSurfaceCreateParams>(),
        32usize,
        concat!("Size of: ", stringify!(NvBufSurfaceCreateParams))
    );
    assert_eq!(
        ::std::mem::align_of::<NvBufSurfaceCreateParams>(),
        4usize,
        concat!("Alignment of ", stringify!(NvBufSurfaceCreateParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceCreateParams),
            "::",
            stringify!(gpuId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceCreateParams),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceCreateParams),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceCreateParams),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isContiguous) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceCreateParams),
            "::",
            stringify!(isContiguous)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceCreateParams),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceCreateParams),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceCreateParams),
            "::",
            stringify!(memType)
        )
    );
}
#[doc = " Hold extended parameters required to allocate NvBufSurface.\n (Applicable for NvBufSurfaceAllocate API)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufSurfaceAllocateParams {
    #[doc = " Hold legacy NvBufSurface creation parameters"]
    pub params: NvBufSurfaceCreateParams,
    #[doc = " Display scan format"]
    pub displayscanformat: NvBufSurfaceDisplayScanFormat,
    #[doc = " Chroma Subsampling parameters"]
    pub chromaSubsampling: NvBufSurfaceChromaSubsamplingParams,
    #[doc = " components tag to be used for memory allocation"]
    pub memtag: NvBufSurfaceTag,
    pub _reserved: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_NvBufSurfaceAllocateParams() {
    const UNINIT: ::std::mem::MaybeUninit<NvBufSurfaceAllocateParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvBufSurfaceAllocateParams>(),
        80usize,
        concat!("Size of: ", stringify!(NvBufSurfaceAllocateParams))
    );
    assert_eq!(
        ::std::mem::align_of::<NvBufSurfaceAllocateParams>(),
        8usize,
        concat!("Alignment of ", stringify!(NvBufSurfaceAllocateParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceAllocateParams),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayscanformat) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceAllocateParams),
            "::",
            stringify!(displayscanformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chromaSubsampling) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceAllocateParams),
            "::",
            stringify!(chromaSubsampling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memtag) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceAllocateParams),
            "::",
            stringify!(memtag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceAllocateParams),
            "::",
            stringify!(_reserved)
        )
    );
}
#[doc = " Hold the pointers of mapped buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufSurfaceMappedAddr {
    #[doc = " Holds planewise pointers to a CPU mapped buffer."]
    pub addr: [*mut ::std::os::raw::c_void; 4usize],
    #[doc = " Holds a pointer to a mapped EGLImage."]
    pub eglImage: *mut ::std::os::raw::c_void,
    pub _reserved: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_NvBufSurfaceMappedAddr() {
    const UNINIT: ::std::mem::MaybeUninit<NvBufSurfaceMappedAddr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvBufSurfaceMappedAddr>(),
        72usize,
        concat!("Size of: ", stringify!(NvBufSurfaceMappedAddr))
    );
    assert_eq!(
        ::std::mem::align_of::<NvBufSurfaceMappedAddr>(),
        8usize,
        concat!("Alignment of ", stringify!(NvBufSurfaceMappedAddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceMappedAddr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eglImage) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceMappedAddr),
            "::",
            stringify!(eglImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceMappedAddr),
            "::",
            stringify!(_reserved)
        )
    );
}
#[doc = " Hold the information(extended) of single buffer in the batch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufSurfaceParamsEx {
    #[doc = " offset in bytes from the start of the buffer to the first valid byte.\n(Applicable for NVBUF_MEM_HANDLE)"]
    pub startofvaliddata: i32,
    #[doc = " size of the valid data from the first to the last valid byte.\n(Applicable for NVBUF_MEM_HANDLE)"]
    pub sizeofvaliddatainbytes: i32,
    #[doc = " chroma subsampling parameters.\n(Applicable for NVBUF_MEM_SURFACE_ARRAY)"]
    pub chromaSubsampling: NvBufSurfaceChromaSubsamplingParams,
    #[doc = " get buffer vpr information."]
    pub is_protected: bool,
    #[doc = " plane wise extended info"]
    pub planeParamsex: NvBufSurfacePlaneParamsEx,
    pub _reserved: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_NvBufSurfaceParamsEx() {
    const UNINIT: ::std::mem::MaybeUninit<NvBufSurfaceParamsEx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvBufSurfaceParamsEx>(),
        272usize,
        concat!("Size of: ", stringify!(NvBufSurfaceParamsEx))
    );
    assert_eq!(
        ::std::mem::align_of::<NvBufSurfaceParamsEx>(),
        8usize,
        concat!("Alignment of ", stringify!(NvBufSurfaceParamsEx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startofvaliddata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParamsEx),
            "::",
            stringify!(startofvaliddata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeofvaliddatainbytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParamsEx),
            "::",
            stringify!(sizeofvaliddatainbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chromaSubsampling) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParamsEx),
            "::",
            stringify!(chromaSubsampling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_protected) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParamsEx),
            "::",
            stringify!(is_protected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planeParamsex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParamsEx),
            "::",
            stringify!(planeParamsex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParamsEx),
            "::",
            stringify!(_reserved)
        )
    );
}
#[doc = " Hold the information of single buffer in the batch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufSurfaceParams {
    #[doc = " Holds the width of the buffer."]
    pub width: u32,
    #[doc = " Holds the height of the buffer."]
    pub height: u32,
    #[doc = " Holds the pitch of the buffer."]
    pub pitch: u32,
    #[doc = " Holds the color format of the buffer."]
    pub colorFormat: NvBufSurfaceColorFormat,
    #[doc = " Holds BL or PL. For dGPU, only PL is valid."]
    pub layout: NvBufSurfaceLayout,
    #[doc = " Holds a DMABUF FD. Valid only for \\ref NVBUF_MEM_SURFACE_ARRAY and\n\\ref NVBUF_MEM_HANDLE type memory."]
    pub bufferDesc: u64,
    #[doc = " Holds the amount of allocated memory."]
    pub dataSize: u32,
    #[doc = " Holds a pointer to allocated memory. Not valid for\n\\ref NVBUF_MEM_SURFACE_ARRAY or \\ref NVBUF_MEM_HANDLE."]
    pub dataPtr: *mut ::std::os::raw::c_void,
    #[doc = " Holds planewise information (width, height, pitch, offset, etc.)."]
    pub planeParams: NvBufSurfacePlaneParams,
    #[doc = " Holds pointers to mapped buffers. Initialized to NULL\nwhen the structure is created."]
    pub mappedAddr: NvBufSurfaceMappedAddr,
    #[doc = " pointers of extended parameters of single buffer in the batch."]
    pub paramex: *mut NvBufSurfaceParamsEx,
    pub _reserved: [*mut ::std::os::raw::c_void; 3usize],
}
#[test]
fn bindgen_test_layout_NvBufSurfaceParams() {
    const UNINIT: ::std::mem::MaybeUninit<NvBufSurfaceParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvBufSurfaceParams>(),
        384usize,
        concat!("Size of: ", stringify!(NvBufSurfaceParams))
    );
    assert_eq!(
        ::std::mem::align_of::<NvBufSurfaceParams>(),
        8usize,
        concat!("Alignment of ", stringify!(NvBufSurfaceParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParams),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParams),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParams),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorFormat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParams),
            "::",
            stringify!(colorFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParams),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferDesc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParams),
            "::",
            stringify!(bufferDesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParams),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataPtr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParams),
            "::",
            stringify!(dataPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planeParams) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParams),
            "::",
            stringify!(planeParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mappedAddr) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParams),
            "::",
            stringify!(mappedAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramex) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParams),
            "::",
            stringify!(paramex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurfaceParams),
            "::",
            stringify!(_reserved)
        )
    );
}
#[doc = " Holds information about batched buffers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufSurface {
    #[doc = " Holds a GPU ID. Valid only for a multi-GPU system."]
    pub gpuId: u32,
    #[doc = " Holds the batch size."]
    pub batchSize: u32,
    #[doc = " Holds the number valid and filled buffers. Initialized to zero when\nan instance of the structure is created."]
    pub numFilled: u32,
    #[doc = " Holds an \"is contiguous\" flag. If set, memory allocated for the batch\nis contiguous."]
    pub isContiguous: bool,
    #[doc = " Holds type of memory for buffers in the batch."]
    pub memType: NvBufSurfaceMemType,
    #[doc = " Holds a pointer to an array of batched buffers."]
    pub surfaceList: *mut NvBufSurfaceParams,
    pub _reserved: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_NvBufSurface() {
    const UNINIT: ::std::mem::MaybeUninit<NvBufSurface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvBufSurface>(),
        64usize,
        concat!("Size of: ", stringify!(NvBufSurface))
    );
    assert_eq!(
        ::std::mem::align_of::<NvBufSurface>(),
        8usize,
        concat!("Alignment of ", stringify!(NvBufSurface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurface),
            "::",
            stringify!(gpuId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batchSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurface),
            "::",
            stringify!(batchSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numFilled) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurface),
            "::",
            stringify!(numFilled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isContiguous) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurface),
            "::",
            stringify!(isContiguous)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurface),
            "::",
            stringify!(memType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).surfaceList) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurface),
            "::",
            stringify!(surfaceList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBufSurface),
            "::",
            stringify!(_reserved)
        )
    );
}
#[doc = " Holds the raw tensor output information for one frame / one object.\n\n The \"nvinfer\" plugins adds this meta when the \"output-tensor-meta\" property\n of the element instance is set to TRUE.\n\n This meta data is added as NvDsUserMeta to the frame_user_meta_list of the\n corresponding frame_meta or object_user_meta_list of the corresponding object\n with the meta_type set to NVDSINFER_TENSOR_OUTPUT_META."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferTensorMeta {
    #[doc = " Unique ID of the gst-nvinfer instance which attached this meta."]
    pub unique_id: guint,
    #[doc = " Number of bound output layers."]
    pub num_output_layers: guint,
    #[doc = " Pointer to the array containing information for the bound output layers.\n Size of the array will be equal to num_output_layers. Pointers inside\n the NvDsInferLayerInfo structure are not valid for this array."]
    pub output_layers_info: *mut NvDsInferLayerInfo,
    #[doc = " Array of pointers to the output host buffers for the batch / frame / object."]
    pub out_buf_ptrs_host: *mut *mut ::std::os::raw::c_void,
    #[doc = " Array of pointers to the output device buffers for the batch / frame / object."]
    pub out_buf_ptrs_dev: *mut *mut ::std::os::raw::c_void,
    #[doc = " GPU device ID on which the device buffers have been allocated."]
    pub gpu_id: gint,
    #[doc = " Private data used for the meta producer's internal memory management."]
    pub priv_data: *mut ::std::os::raw::c_void,
    #[doc = " Network information for the model specified for the nvinfer element instance."]
    pub network_info: NvDsInferNetworkInfo,
    #[doc = " Whether aspect ratio was maintained while scaling to network resolution"]
    pub maintain_aspect_ratio: gboolean,
}
#[test]
fn bindgen_test_layout_NvDsInferTensorMeta() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferTensorMeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferTensorMeta>(),
        64usize,
        concat!("Size of: ", stringify!(NvDsInferTensorMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferTensorMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsInferTensorMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unique_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferTensorMeta),
            "::",
            stringify!(unique_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_output_layers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferTensorMeta),
            "::",
            stringify!(num_output_layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_layers_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferTensorMeta),
            "::",
            stringify!(output_layers_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_buf_ptrs_host) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferTensorMeta),
            "::",
            stringify!(out_buf_ptrs_host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_buf_ptrs_dev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferTensorMeta),
            "::",
            stringify!(out_buf_ptrs_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferTensorMeta),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferTensorMeta),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).network_info) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferTensorMeta),
            "::",
            stringify!(network_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maintain_aspect_ratio) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferTensorMeta),
            "::",
            stringify!(maintain_aspect_ratio)
        )
    );
}
#[doc = " Holds the segmentation model output information for one frame / one object.\n\n The \"nvinfer\" plugins adds this meta for segmentation models.\n\n This meta data is added as NvDsUserMeta to the frame_user_meta_list of the\n corresponding frame_meta or object_user_meta_list of the corresponding object\n with the meta_type set to NVDSINFER_SEGMENTATION_META."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferSegmentationMeta {
    #[doc = " Number of classes in the segmentation output."]
    pub classes: guint,
    #[doc = " Width of the segmentation output class map."]
    pub width: guint,
    #[doc = " Height of the segmentation output class map."]
    pub height: guint,
    #[doc = " Pointer to the array for 2D pixel class map. The output for pixel (x,y)\n will be at index (y * width + x)."]
    pub class_map: *mut gint,
    #[doc = " Pointer to the raw array containing the probabilities. The probability for\n class c and pixel (x,y) will be at index (c * width *height + y * width + x)."]
    pub class_probabilities_map: *mut gfloat,
    #[doc = " Private data used for the meta producer's internal memory management."]
    pub priv_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_NvDsInferSegmentationMeta() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferSegmentationMeta> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferSegmentationMeta>(),
        40usize,
        concat!("Size of: ", stringify!(NvDsInferSegmentationMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferSegmentationMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsInferSegmentationMeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferSegmentationMeta),
            "::",
            stringify!(classes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferSegmentationMeta),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferSegmentationMeta),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_map) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferSegmentationMeta),
            "::",
            stringify!(class_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_probabilities_map) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferSegmentationMeta),
            "::",
            stringify!(class_probabilities_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferSegmentationMeta),
            "::",
            stringify!(priv_data)
        )
    );
}
pub const NvDsInferNetworkMode_NvDsInferNetworkMode_FP32: NvDsInferNetworkMode = 0;
pub const NvDsInferNetworkMode_NvDsInferNetworkMode_INT8: NvDsInferNetworkMode = 1;
pub const NvDsInferNetworkMode_NvDsInferNetworkMode_FP16: NvDsInferNetworkMode = 2;
#[doc = " Defines internal data formats used by the inference engine."]
pub type NvDsInferNetworkMode = ::std::os::raw::c_uint;
#[doc = " Specifies a detector. Detectors find objects and their coordinates,\nand their classes in an input frame."]
pub const NvDsInferNetworkType_NvDsInferNetworkType_Detector: NvDsInferNetworkType = 0;
#[doc = " Specifies a classifier. Classifiers classify an entire frame into\none of several classes."]
pub const NvDsInferNetworkType_NvDsInferNetworkType_Classifier: NvDsInferNetworkType = 1;
#[doc = " Specifies a segmentation network. A segmentation network classifies\neach pixel into one of several classes."]
pub const NvDsInferNetworkType_NvDsInferNetworkType_Segmentation: NvDsInferNetworkType = 2;
#[doc = " Specifies a instance segmentation network. A instance segmentation\nnetwork detects objects, bounding box and mask for objects, and\ntheir classes in an input frame"]
pub const NvDsInferNetworkType_NvDsInferNetworkType_InstanceSegmentation: NvDsInferNetworkType = 3;
#[doc = " Specifies other. Output layers of an \"other\" network are not parsed by\nNvDsInferContext. This is useful for networks that produce custom output.\nOutput can be parsed by the NvDsInferContext client or can be combined\nwith the Gst-nvinfer feature to flow output tensors as metadata."]
pub const NvDsInferNetworkType_NvDsInferNetworkType_Other: NvDsInferNetworkType = 100;
#[doc = " Defines network types."]
pub type NvDsInferNetworkType = ::std::os::raw::c_uint;
#[doc = " Specifies 24-bit interleaved R-G-B format."]
pub const NvDsInferFormat_NvDsInferFormat_RGB: NvDsInferFormat = 0;
#[doc = " Specifies 24-bit interleaved B-G-R format."]
pub const NvDsInferFormat_NvDsInferFormat_BGR: NvDsInferFormat = 1;
#[doc = " Specifies 8-bit Luma format."]
pub const NvDsInferFormat_NvDsInferFormat_GRAY: NvDsInferFormat = 2;
#[doc = " Specifies 32-bit interleaved R-G-B-A format."]
pub const NvDsInferFormat_NvDsInferFormat_RGBA: NvDsInferFormat = 3;
#[doc = " Specifies 32-bit interleaved B-G-R-x format."]
pub const NvDsInferFormat_NvDsInferFormat_BGRx: NvDsInferFormat = 4;
#[doc = " NCHW planar"]
pub const NvDsInferFormat_NvDsInferFormat_Tensor: NvDsInferFormat = 5;
#[doc = " NCHW planar"]
pub const NvDsInferFormat_NvDsInferFormat_Unknown: NvDsInferFormat = 4294967295;
#[doc = " Defines color formats."]
pub type NvDsInferFormat = ::std::os::raw::c_uint;
pub const NvDsInferTensorOrder_NvDsInferTensorOrder_kNCHW: NvDsInferTensorOrder = 0;
pub const NvDsInferTensorOrder_NvDsInferTensorOrder_kNHWC: NvDsInferTensorOrder = 1;
pub const NvDsInferTensorOrder_NvDsInferTensorOrder_kNC: NvDsInferTensorOrder = 2;
pub const NvDsInferTensorOrder_NvDsInferUffOrder_kNCHW: NvDsInferTensorOrder = 0;
pub const NvDsInferTensorOrder_NvDsInferUffOrder_kNHWC: NvDsInferTensorOrder = 1;
pub const NvDsInferTensorOrder_NvDsInferUffOrder_kNC: NvDsInferTensorOrder = 2;
#[doc = " Defines UFF input layer orders."]
pub type NvDsInferTensorOrder = ::std::os::raw::c_uint;
#[doc = " Holds detection and bounding box grouping parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvDsInferDetectionParams {
    pub __bindgen_anon_1: NvDsInferDetectionParams__bindgen_ty_1,
    #[doc = " Hold the bounding box detection threshold to be applied post\n clustering operation."]
    pub postClusterThreshold: f32,
    #[doc = " Holds the epsilon to control merging of overlapping boxes. Refer to OpenCV\n groupRectangles and DBSCAN documentation for more information on epsilon."]
    pub eps: f32,
    #[doc = " Holds the minimum number of boxes in a cluster to be considered\nan object during grouping using DBSCAN."]
    pub minBoxes: ::std::os::raw::c_int,
    #[doc = " Holds the minimum number boxes in a cluster to be considered\nan object during grouping using OpenCV groupRectangles."]
    pub groupThreshold: ::std::os::raw::c_int,
    #[doc = " Minimum score in a cluster for the cluster to be considered an object\nduring grouping. Different clustering may cause the algorithm\nto use different scores."]
    pub minScore: f32,
    #[doc = " IOU threshold to be used with NMS mode of clustering."]
    pub nmsIOUThreshold: f32,
    #[doc = " Number of objects with objects to be filtered in the decensding order\n of probability"]
    pub topK: ::std::os::raw::c_int,
}
#[doc = " Holds the bounding box detection threshold to be applied prior\n to clustering operation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union NvDsInferDetectionParams__bindgen_ty_1 {
    pub threshold: f32,
    pub preClusterThreshold: f32,
}
#[test]
fn bindgen_test_layout_NvDsInferDetectionParams__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferDetectionParams__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferDetectionParams__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(NvDsInferDetectionParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferDetectionParams__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NvDsInferDetectionParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDetectionParams__bindgen_ty_1),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preClusterThreshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDetectionParams__bindgen_ty_1),
            "::",
            stringify!(preClusterThreshold)
        )
    );
}
#[test]
fn bindgen_test_layout_NvDsInferDetectionParams() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferDetectionParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferDetectionParams>(),
        32usize,
        concat!("Size of: ", stringify!(NvDsInferDetectionParams))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferDetectionParams>(),
        4usize,
        concat!("Alignment of ", stringify!(NvDsInferDetectionParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).postClusterThreshold) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDetectionParams),
            "::",
            stringify!(postClusterThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eps) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDetectionParams),
            "::",
            stringify!(eps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minBoxes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDetectionParams),
            "::",
            stringify!(minBoxes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).groupThreshold) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDetectionParams),
            "::",
            stringify!(groupThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minScore) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDetectionParams),
            "::",
            stringify!(minScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nmsIOUThreshold) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDetectionParams),
            "::",
            stringify!(nmsIOUThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topK) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDetectionParams),
            "::",
            stringify!(topK)
        )
    );
}
pub const NvDsInferClusterMode_NVDSINFER_CLUSTER_GROUP_RECTANGLES: NvDsInferClusterMode = 0;
pub const NvDsInferClusterMode_NVDSINFER_CLUSTER_DBSCAN: NvDsInferClusterMode = 1;
pub const NvDsInferClusterMode_NVDSINFER_CLUSTER_NMS: NvDsInferClusterMode = 2;
pub const NvDsInferClusterMode_NVDSINFER_CLUSTER_DBSCAN_NMS_HYBRID: NvDsInferClusterMode = 3;
pub const NvDsInferClusterMode_NVDSINFER_CLUSTER_NONE: NvDsInferClusterMode = 4;
#[doc = " Enum for clustering mode for detectors"]
pub type NvDsInferClusterMode = ::std::os::raw::c_uint;
#[doc = " Holds the initialization parameters required for the NvDsInferContext interface."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NvDsInferContextInitParams {
    #[doc = " Holds a unique identifier for the instance. This can be used\nto identify the instance that is generating log and error messages."]
    pub uniqueID: ::std::os::raw::c_uint,
    #[doc = " Holds an internal data format specifier used by the inference engine."]
    pub networkMode: NvDsInferNetworkMode,
    #[doc = " Holds the pathname of the prototxt file."]
    pub protoFilePath: [::std::os::raw::c_char; 4096usize],
    #[doc = " Holds the pathname of the caffemodel file."]
    pub modelFilePath: [::std::os::raw::c_char; 4096usize],
    #[doc = " Holds the pathname of the UFF model file."]
    pub uffFilePath: [::std::os::raw::c_char; 4096usize],
    #[doc = " Holds the pathname of the ONNX model file."]
    pub onnxFilePath: [::std::os::raw::c_char; 4096usize],
    #[doc = " Holds the pathname of the TLT encoded model file."]
    pub tltEncodedModelFilePath: [::std::os::raw::c_char; 4096usize],
    #[doc = " Holds the pathname of the INT8 calibration file.\nRequired only when using INT8 mode."]
    pub int8CalibrationFilePath: [::std::os::raw::c_char; 4096usize],
    pub __bindgen_anon_1: _NvDsInferContextInitParams__bindgen_ty_1,
    #[doc = " Holds the original input order for the UFF model."]
    pub uffInputOrder: NvDsInferTensorOrder,
    #[doc = " Holds the name of the input layer for the UFF model."]
    pub uffInputBlobName: [::std::os::raw::c_char; 1024usize],
    #[doc = " Holds the original input order for the network."]
    pub netInputOrder: NvDsInferTensorOrder,
    #[doc = " Holds the string key for decoding the TLT encoded model."]
    pub tltModelKey: [::std::os::raw::c_char; 1024usize],
    #[doc = " Holds the pathname of the serialized model engine file.\nWhen using the model engine file, other parameters required for creating\nthe model engine are ignored."]
    pub modelEngineFilePath: [::std::os::raw::c_char; 4096usize],
    #[doc = " Holds the maximum number of frames to be inferred together in a batch.\nThe number of input frames in a batch must be\nless than or equal to this."]
    pub maxBatchSize: ::std::os::raw::c_uint,
    #[doc = " Holds the pathname of the labels file containing strings for the class\nlabels. The labels file is optional. The file format is described in the\ncustom models section of the DeepStream SDK documentation."]
    pub labelsFilePath: [::std::os::raw::c_char; 4096usize],
    #[doc = " Holds the pathname of the mean image file (PPM format). File resolution\nmust be equal to the network input resolution."]
    pub meanImageFilePath: [::std::os::raw::c_char; 4096usize],
    #[doc = " Holds the normalization factor with which to scale the input pixels."]
    pub networkScaleFactor: f32,
    #[doc = " Holds the network input format."]
    pub networkInputFormat: NvDsInferFormat,
    #[doc = " Holds the per-channel offsets for mean subtraction. This is\nan alternative to the mean image file. The number of offsets in the array\nmust be equal to the number of input channels."]
    pub offsets: [f32; 4usize],
    pub numOffsets: ::std::os::raw::c_uint,
    #[doc = " Holds the network type."]
    pub networkType: NvDsInferNetworkType,
    #[doc = " Holds a Boolean; true if DBScan is to be used for object clustering,\nor false if OpenCV groupRectangles is to be used."]
    pub useDBScan: ::std::os::raw::c_int,
    #[doc = " Holds the number of classes detected by a detector network."]
    pub numDetectedClasses: ::std::os::raw::c_uint,
    #[doc = " Holds per-class detection parameters. The array's size must be equal\nto @a numDetectedClasses."]
    pub perClassDetectionParams: *mut NvDsInferDetectionParams,
    #[doc = " Holds the minimum confidence threshold for the classifier to consider\na label valid."]
    pub classifierThreshold: f32,
    pub segmentationThreshold: f32,
    #[doc = " Holds a pointer to an array of pointers to output layer names."]
    pub outputLayerNames: *mut *mut ::std::os::raw::c_char,
    #[doc = " Holds the number of output layer names."]
    pub numOutputLayers: ::std::os::raw::c_uint,
    #[doc = " Holds the pathname of the library containing custom methods\nrequired to support the network."]
    pub customLibPath: [::std::os::raw::c_char; 4096usize],
    #[doc = " Holds the name of the custom bounding box function\nin the custom library."]
    pub customBBoxParseFuncName: [::std::os::raw::c_char; 1024usize],
    #[doc = " Name of the custom classifier attribute parsing function in the custom\n  library."]
    pub customClassifierParseFuncName: [::std::os::raw::c_char; 1024usize],
    #[doc = " Holds a Boolean; true if the input layer contents are to be copied to\nhost memory for access by the application."]
    pub copyInputToHostBuffers: ::std::os::raw::c_int,
    #[doc = " Holds the ID of the GPU which is to run the inference."]
    pub gpuID: ::std::os::raw::c_uint,
    #[doc = " Holds a Boolean; true if DLA is to be used."]
    pub useDLA: ::std::os::raw::c_int,
    #[doc = " Holds the ID of the DLA core to use."]
    pub dlaCore: ::std::os::raw::c_int,
    #[doc = " Holds the number of sets of output buffers (host and device)\nto be allocated."]
    pub outputBufferPoolSize: ::std::os::raw::c_uint,
    #[doc = " Holds the pathname of the configuration file\nfor custom network creation. This can be used to store custom properties\nrequired by the custom network creation function."]
    pub customNetworkConfigFilePath: [::std::os::raw::c_char; 4096usize],
    #[doc = " Name of the custom engine creation function in the custom library."]
    pub customEngineCreateFuncName: [::std::os::raw::c_char; 1024usize],
    #[doc = " For model parsers supporting both implicit batch dim and full dims,\n prefer to use implicit batch dim. By default, full dims network mode is\n used."]
    pub forceImplicitBatchDimension: ::std::os::raw::c_int,
    #[doc = " Max workspace size (unit MB) that will be used as tensorrt build\n settings for cuda engine."]
    pub workspaceSize: ::std::os::raw::c_uint,
    #[doc = " Inference input dimensions for runtime engine"]
    pub inferInputDims: NvDsInferDimsCHW,
    #[doc = " Holds the type of clustering mode"]
    pub clusterMode: NvDsInferClusterMode,
    #[doc = " Holds the name of the bounding box and instance mask parse function\nin the custom library."]
    pub customBBoxInstanceMaskParseFuncName: [::std::os::raw::c_char; 1024usize],
    #[doc = " Can be used to specify the format and datatype for bound output layers.\n For each layer specified the format is\n \"<layer-name>:<data-type>:<format>\""]
    pub outputIOFormats: *mut *mut ::std::os::raw::c_char,
    #[doc = " Holds number of output IO formats specified."]
    pub numOutputIOFormats: ::std::os::raw::c_uint,
    #[doc = "Can be used to specify the device type and inference precision of layers.\n For each layer specified the format is\n \"<layer-name>:<device-type>:<precision>\""]
    pub layerDevicePrecisions: *mut *mut ::std::os::raw::c_char,
    #[doc = " Holds number of layer device precisions specified"]
    pub numLayerDevicePrecisions: ::std::os::raw::c_uint,
    #[doc = " Holds output order for segmentation network"]
    pub segmentationOutputOrder: NvDsInferTensorOrder,
    #[doc = " Boolean flag indicating that caller will supply preprocessed tensors for\n  inferencing. NvDsInferContext will skip preprocessing initialization steps\n  and will not interpret network input layer dimensions."]
    pub inputFromPreprocessedTensor: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NvDsInferContextInitParams__bindgen_ty_1 {
    #[doc = " Holds the input dimensions for the model."]
    pub inputDims: NvDsInferDimsCHW,
    #[doc = " Holds the input dimensions for the UFF model."]
    pub uffDimsCHW: NvDsInferDimsCHW,
}
#[test]
fn bindgen_test_layout__NvDsInferContextInitParams__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsInferContextInitParams__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsInferContextInitParams__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_NvDsInferContextInitParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsInferContextInitParams__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NvDsInferContextInitParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputDims) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams__bindgen_ty_1),
            "::",
            stringify!(inputDims)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uffDimsCHW) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams__bindgen_ty_1),
            "::",
            stringify!(uffDimsCHW)
        )
    );
}
#[test]
fn bindgen_test_layout__NvDsInferContextInitParams() {
    const UNINIT: ::std::mem::MaybeUninit<_NvDsInferContextInitParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NvDsInferContextInitParams>(),
        51384usize,
        concat!("Size of: ", stringify!(_NvDsInferContextInitParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsInferContextInitParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsInferContextInitParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uniqueID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(uniqueID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).networkMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(networkMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protoFilePath) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(protoFilePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modelFilePath) as usize - ptr as usize },
        4104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(modelFilePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uffFilePath) as usize - ptr as usize },
        8200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(uffFilePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onnxFilePath) as usize - ptr as usize },
        12296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(onnxFilePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tltEncodedModelFilePath) as usize - ptr as usize },
        16392usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(tltEncodedModelFilePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int8CalibrationFilePath) as usize - ptr as usize },
        20488usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(int8CalibrationFilePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uffInputOrder) as usize - ptr as usize },
        24596usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(uffInputOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uffInputBlobName) as usize - ptr as usize },
        24600usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(uffInputBlobName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).netInputOrder) as usize - ptr as usize },
        25624usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(netInputOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tltModelKey) as usize - ptr as usize },
        25628usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(tltModelKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modelEngineFilePath) as usize - ptr as usize },
        26652usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(modelEngineFilePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBatchSize) as usize - ptr as usize },
        30748usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(maxBatchSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).labelsFilePath) as usize - ptr as usize },
        30752usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(labelsFilePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meanImageFilePath) as usize - ptr as usize },
        34848usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(meanImageFilePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).networkScaleFactor) as usize - ptr as usize },
        38944usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(networkScaleFactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).networkInputFormat) as usize - ptr as usize },
        38948usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(networkInputFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsets) as usize - ptr as usize },
        38952usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(offsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numOffsets) as usize - ptr as usize },
        38968usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(numOffsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).networkType) as usize - ptr as usize },
        38972usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(networkType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useDBScan) as usize - ptr as usize },
        38976usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(useDBScan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numDetectedClasses) as usize - ptr as usize },
        38980usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(numDetectedClasses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).perClassDetectionParams) as usize - ptr as usize },
        38984usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(perClassDetectionParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classifierThreshold) as usize - ptr as usize },
        38992usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(classifierThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmentationThreshold) as usize - ptr as usize },
        38996usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(segmentationThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputLayerNames) as usize - ptr as usize },
        39000usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(outputLayerNames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numOutputLayers) as usize - ptr as usize },
        39008usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(numOutputLayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customLibPath) as usize - ptr as usize },
        39012usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(customLibPath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customBBoxParseFuncName) as usize - ptr as usize },
        43108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(customBBoxParseFuncName)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).customClassifierParseFuncName) as usize - ptr as usize
        },
        44132usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(customClassifierParseFuncName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyInputToHostBuffers) as usize - ptr as usize },
        45156usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(copyInputToHostBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuID) as usize - ptr as usize },
        45160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(gpuID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useDLA) as usize - ptr as usize },
        45164usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(useDLA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dlaCore) as usize - ptr as usize },
        45168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(dlaCore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputBufferPoolSize) as usize - ptr as usize },
        45172usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(outputBufferPoolSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customNetworkConfigFilePath) as usize - ptr as usize },
        45176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(customNetworkConfigFilePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customEngineCreateFuncName) as usize - ptr as usize },
        49272usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(customEngineCreateFuncName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forceImplicitBatchDimension) as usize - ptr as usize },
        50296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(forceImplicitBatchDimension)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).workspaceSize) as usize - ptr as usize },
        50300usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(workspaceSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inferInputDims) as usize - ptr as usize },
        50304usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(inferInputDims)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clusterMode) as usize - ptr as usize },
        50316usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(clusterMode)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).customBBoxInstanceMaskParseFuncName) as usize - ptr as usize
        },
        50320usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(customBBoxInstanceMaskParseFuncName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputIOFormats) as usize - ptr as usize },
        51344usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(outputIOFormats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numOutputIOFormats) as usize - ptr as usize },
        51352usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(numOutputIOFormats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layerDevicePrecisions) as usize - ptr as usize },
        51360usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(layerDevicePrecisions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numLayerDevicePrecisions) as usize - ptr as usize },
        51368usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(numLayerDevicePrecisions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmentationOutputOrder) as usize - ptr as usize },
        51372usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(segmentationOutputOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputFromPreprocessedTensor) as usize - ptr as usize },
        51376usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsInferContextInitParams),
            "::",
            stringify!(inputFromPreprocessedTensor)
        )
    );
}
#[doc = " Holds the initialization parameters required for the NvDsInferContext interface."]
pub type NvDsInferContextInitParams = _NvDsInferContextInitParams;
#[doc = " Defines a callback function type for asynchronously returning\n the input client buffers to the NvDsInferContext client.\n\n @param[in] data  An opaque pointer provided to the input queueing function\n                  through NvDsInferContextBatchInput."]
pub type NvDsInferContextReturnInputAsyncFunc =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
#[doc = " Holds information about one batch to be inferred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferContextBatchInput {
    #[doc = " Holds a pointer to an array of pointers to input frame buffers.\nThe size of the array must be at least @a numInputFrames."]
    pub inputFrames: *mut *mut ::std::os::raw::c_void,
    #[doc = " Holds the number of input frames, i.e. the size of the batch."]
    pub numInputFrames: ::std::os::raw::c_uint,
    #[doc = " Holds the format of the frame contents."]
    pub inputFormat: NvDsInferFormat,
    #[doc = " Holds the pitch of the input frames, in bytes."]
    pub inputPitch: ::std::os::raw::c_uint,
    #[doc = " Holds a callback for returning the input buffers to the client."]
    pub returnInputFunc: NvDsInferContextReturnInputAsyncFunc,
    #[doc = " A pointer to the data to be supplied with the callback in\n@a returnInputFunc."]
    pub returnFuncData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_NvDsInferContextBatchInput() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferContextBatchInput> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferContextBatchInput>(),
        40usize,
        concat!("Size of: ", stringify!(NvDsInferContextBatchInput))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferContextBatchInput>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsInferContextBatchInput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputFrames) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchInput),
            "::",
            stringify!(inputFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numInputFrames) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchInput),
            "::",
            stringify!(numInputFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputFormat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchInput),
            "::",
            stringify!(inputFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputPitch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchInput),
            "::",
            stringify!(inputPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).returnInputFunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchInput),
            "::",
            stringify!(returnInputFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).returnFuncData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchInput),
            "::",
            stringify!(returnFuncData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferContextBatchPreprocessedInput {
    pub tensors: *mut NvDsInferLayerInfo,
    #[doc = " Holds the number of input tensors."]
    pub numInputTensors: ::std::os::raw::c_uint,
    #[doc = " Holds a callback for returning the input buffers to the client."]
    pub returnInputFunc: NvDsInferContextReturnInputAsyncFunc,
    #[doc = " A pointer to the data to be supplied with the callback in\n@a returnInputFunc."]
    pub returnFuncData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_NvDsInferContextBatchPreprocessedInput() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferContextBatchPreprocessedInput> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferContextBatchPreprocessedInput>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(NvDsInferContextBatchPreprocessedInput)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferContextBatchPreprocessedInput>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NvDsInferContextBatchPreprocessedInput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tensors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchPreprocessedInput),
            "::",
            stringify!(tensors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numInputTensors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchPreprocessedInput),
            "::",
            stringify!(numInputTensors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).returnInputFunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchPreprocessedInput),
            "::",
            stringify!(returnInputFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).returnFuncData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchPreprocessedInput),
            "::",
            stringify!(returnFuncData)
        )
    );
}
#[doc = " Holds information about one detected object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferObject {
    #[doc = " Holds the object's offset from the left boundary of the frame."]
    pub left: f32,
    #[doc = " Holds the object's offset from the top boundary of the frame."]
    pub top: f32,
    #[doc = " Holds the object's width."]
    pub width: f32,
    #[doc = " Holds the object's height."]
    pub height: f32,
    #[doc = " Holds the index for the object's class."]
    pub classIndex: ::std::os::raw::c_int,
    #[doc = " Holds a pointer to a string containing a label for the object."]
    pub label: *mut ::std::os::raw::c_char,
    pub confidence: f32,
    pub mask: *mut f32,
    #[doc = " Holds width of mask"]
    pub mask_width: ::std::os::raw::c_uint,
    #[doc = " Holds height of mask"]
    pub mask_height: ::std::os::raw::c_uint,
    #[doc = " Holds size of mask in bytes"]
    pub mask_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_NvDsInferObject() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferObject>(),
        64usize,
        concat!("Size of: ", stringify!(NvDsInferObject))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferObject>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsInferObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObject),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObject),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObject),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObject),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObject),
            "::",
            stringify!(classIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObject),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).confidence) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObject),
            "::",
            stringify!(confidence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObject),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_width) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObject),
            "::",
            stringify!(mask_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_height) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObject),
            "::",
            stringify!(mask_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferObject),
            "::",
            stringify!(mask_size)
        )
    );
}
#[doc = " Holds information on all objects detected by a detector network in one\n frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferDetectionOutput {
    #[doc = " Holds a pointer to an array of objects."]
    pub objects: *mut NvDsInferObject,
    #[doc = " Holds the number of objects in @a objects."]
    pub numObjects: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_NvDsInferDetectionOutput() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferDetectionOutput> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferDetectionOutput>(),
        16usize,
        concat!("Size of: ", stringify!(NvDsInferDetectionOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferDetectionOutput>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsInferDetectionOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objects) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDetectionOutput),
            "::",
            stringify!(objects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numObjects) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferDetectionOutput),
            "::",
            stringify!(numObjects)
        )
    );
}
#[doc = " Holds information on all attributes classifed by a classifier network for\n one frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferClassificationOutput {
    #[doc = " Holds a pointer to an array of attributes. There may be more than\none attribute, depending on the number of output coverage layers\n(multi-label classifiers)."]
    pub attributes: *mut NvDsInferAttribute,
    #[doc = " Holds the size of the @a attributes array."]
    pub numAttributes: ::std::os::raw::c_uint,
    #[doc = " Holds a pointer to a string containing a label for the\nclassified output."]
    pub label: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NvDsInferClassificationOutput() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferClassificationOutput> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferClassificationOutput>(),
        24usize,
        concat!("Size of: ", stringify!(NvDsInferClassificationOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferClassificationOutput>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsInferClassificationOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferClassificationOutput),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAttributes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferClassificationOutput),
            "::",
            stringify!(numAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferClassificationOutput),
            "::",
            stringify!(label)
        )
    );
}
#[doc = " Holds information parsed from segmentation network output for one frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferSegmentationOutput {
    #[doc = " Holds the width of the output. Same as network width."]
    pub width: ::std::os::raw::c_uint,
    #[doc = " Holds the height of the output. Same as network height."]
    pub height: ::std::os::raw::c_uint,
    #[doc = " Holds the number of classes supported by the network."]
    pub classes: ::std::os::raw::c_uint,
    #[doc = " Holds a pointer to an array for the 2D pixel class map.\nThe output for pixel (x,y) is at index (y*width+x)."]
    pub class_map: *mut ::std::os::raw::c_int,
    #[doc = " Holds a pointer to an array containing raw probabilities.\nThe probability for class @a c and pixel (x,y) is at index\n(c*width*height + y*width+x)."]
    pub class_probability_map: *mut f32,
}
#[test]
fn bindgen_test_layout_NvDsInferSegmentationOutput() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferSegmentationOutput> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferSegmentationOutput>(),
        32usize,
        concat!("Size of: ", stringify!(NvDsInferSegmentationOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferSegmentationOutput>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsInferSegmentationOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferSegmentationOutput),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferSegmentationOutput),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferSegmentationOutput),
            "::",
            stringify!(classes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_map) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferSegmentationOutput),
            "::",
            stringify!(class_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_probability_map) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferSegmentationOutput),
            "::",
            stringify!(class_probability_map)
        )
    );
}
#[doc = " Holds the information inferred by the network on one frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvDsInferFrameOutput {
    #[doc = " Holds an output type indicating the valid member in the union\nof @a detectionOutput, @a classificationOutput, and @a  segmentationOutput.\nThis is basically the network type."]
    pub outputType: NvDsInferNetworkType,
    pub __bindgen_anon_1: NvDsInferFrameOutput__bindgen_ty_1,
}
#[doc = " Holds a union of supported outputs. The valid member is determined by\n@a outputType."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union NvDsInferFrameOutput__bindgen_ty_1 {
    #[doc = " Holds detector output. Valid when @a outputType is\n@ref NvDsInferNetworkType_Detector."]
    pub detectionOutput: NvDsInferDetectionOutput,
    #[doc = " Holds classifier output. Valid when @a outputType is\n@ref NvDsInferNetworkType_Classifier."]
    pub classificationOutput: NvDsInferClassificationOutput,
    #[doc = " Holds classifier output. Valid when @a outputType is\n@ref NvDsInferNetworkType_Classifier."]
    pub segmentationOutput: NvDsInferSegmentationOutput,
}
#[test]
fn bindgen_test_layout_NvDsInferFrameOutput__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferFrameOutput__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferFrameOutput__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(NvDsInferFrameOutput__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferFrameOutput__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NvDsInferFrameOutput__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detectionOutput) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferFrameOutput__bindgen_ty_1),
            "::",
            stringify!(detectionOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classificationOutput) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferFrameOutput__bindgen_ty_1),
            "::",
            stringify!(classificationOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmentationOutput) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferFrameOutput__bindgen_ty_1),
            "::",
            stringify!(segmentationOutput)
        )
    );
}
#[test]
fn bindgen_test_layout_NvDsInferFrameOutput() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferFrameOutput> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferFrameOutput>(),
        40usize,
        concat!("Size of: ", stringify!(NvDsInferFrameOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferFrameOutput>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsInferFrameOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferFrameOutput),
            "::",
            stringify!(outputType)
        )
    );
}
#[doc = " Holds the output for all of the frames in a batch (an array of frame),\n and related buffer information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsInferContextBatchOutput {
    #[doc = " Holds a pointer to an array of outputs for each frame in the batch."]
    pub frames: *mut NvDsInferFrameOutput,
    #[doc = " Holds the number of elements in @a frames."]
    pub numFrames: ::std::os::raw::c_uint,
    #[doc = " Holds a pointer to an array of pointers to output device buffers\nfor this batch. The array elements are set by"]
    pub outputDeviceBuffers: *mut *mut ::std::os::raw::c_void,
    #[doc = " Holds the number of elements in @a *outputDeviceBuffers."]
    pub numOutputDeviceBuffers: ::std::os::raw::c_uint,
    #[doc = " Holds a pointer to an array of pointers to host buffers for this batch.\nThe array elements are set by"]
    pub hostBuffers: *mut *mut ::std::os::raw::c_void,
    #[doc = " Holds the number of elements in hostBuffers."]
    pub numHostBuffers: ::std::os::raw::c_uint,
    #[doc = " Holds a private context pointer for the set of output buffers."]
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_NvDsInferContextBatchOutput() {
    const UNINIT: ::std::mem::MaybeUninit<NvDsInferContextBatchOutput> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NvDsInferContextBatchOutput>(),
        56usize,
        concat!("Size of: ", stringify!(NvDsInferContextBatchOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsInferContextBatchOutput>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsInferContextBatchOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchOutput),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numFrames) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchOutput),
            "::",
            stringify!(numFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputDeviceBuffers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchOutput),
            "::",
            stringify!(outputDeviceBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numOutputDeviceBuffers) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchOutput),
            "::",
            stringify!(numOutputDeviceBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostBuffers) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchOutput),
            "::",
            stringify!(hostBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numHostBuffers) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchOutput),
            "::",
            stringify!(numHostBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsInferContextBatchOutput),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct INvDsInferContext {
    _unused: [u8; 0],
}
#[doc = " An opaque pointer type to be used as a handle for a context instance."]
pub type NvDsInferContextHandle = *mut INvDsInferContext;
#[doc = " @brief  Type declaration for a logging callback.\n\n The callaback log NvDsInferContext messages.\n\n @param[in] handle        The handle of the NvDsInferContext instance that\n                          generated the log.\n @param[in] uniqueID      Unique ID of the NvDsInferContext instance that\n                          generated the log.\n @param[in] logLevel      Level of the log.\n @param[in] funcName      A pointer to the name of the function that\n                          generated the log.\n @param[in] logMessage    A pointer to the log message string.\n @param[in] userCtx       An opaque pointer to the user context, supplied\n                          when creating the NvDsInferContext instance."]
pub type NvDsInferContextLoggingFunc = ::std::option::Option<
    unsafe extern "C" fn(
        handle: NvDsInferContextHandle,
        uniqueID: ::std::os::raw::c_uint,
        logLevel: NvDsInferLogLevel,
        logMessage: *const ::std::os::raw::c_char,
        userCtx: *mut ::std::os::raw::c_void,
    ),
>;
