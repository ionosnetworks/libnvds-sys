/* automatically generated by rust-bindgen 0.59.1 */

pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gsize = ::std::os::raw::c_ulong;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type GQuark = guint32;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GMutex>(),
        8usize,
        concat!("Size of: ", stringify!(_GMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMutex>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMutex>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRecMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GRecMutex>(),
        16usize,
        concat!("Size of: ", stringify!(_GRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRecMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRecMutex>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRecMutex>())).i as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    assert_eq!(
        ::std::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
pub type GType = gsize;
pub type GTypeClass = _GTypeClass;
pub type GTypeInstance = _GTypeInstance;
#[doc = " GTypeClass:"]
#[doc = ""]
#[doc = " An opaque structure used as the base of all classes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeClass>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeClass>())).g_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeClass),
            "::",
            stringify!(g_type)
        )
    );
}
#[doc = " GTypeInstance:"]
#[doc = ""]
#[doc = " An opaque structure used as the base of all type instances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[test]
fn bindgen_test_layout__GTypeInstance() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeInstance>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInstance>())).g_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInstance),
            "::",
            stringify!(g_class)
        )
    );
}
pub type GInitiallyUnowned = _GObject;
#[doc = " GObject:"]
#[doc = ""]
#[doc = " All the fields in the GObject structure are private"]
#[doc = " to the #GObject implementation and should never be accessed directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[test]
fn bindgen_test_layout__GObject() {
    assert_eq!(
        ::std::mem::size_of::<_GObject>(),
        24usize,
        concat!("Size of: ", stringify!(_GObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).g_type_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).ref_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).qdata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(qdata)
        )
    );
}
pub type GstObject = _GstObject;
#[doc = " GstObject:"]
#[doc = " @lock: object LOCK"]
#[doc = " @name: The name of the object"]
#[doc = " @parent: this object's parent, weak ref"]
#[doc = " @flags: flags for this object"]
#[doc = ""]
#[doc = " GStreamer base object class."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstObject {
    pub object: GInitiallyUnowned,
    pub lock: GMutex,
    pub name: *mut gchar,
    pub parent: *mut GstObject,
    pub flags: guint32,
    pub control_bindings: *mut GList,
    pub control_rate: guint64,
    pub last_sync: guint64,
    pub _gst_reserved: gpointer,
}
#[test]
fn bindgen_test_layout__GstObject() {
    assert_eq!(
        ::std::mem::size_of::<_GstObject>(),
        88usize,
        concat!("Size of: ", stringify!(_GstObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GstObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GstObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstObject>())).object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstObject>())).lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstObject>())).name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstObject>())).parent as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstObject>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstObject>())).control_bindings as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(control_bindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstObject>())).control_rate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(control_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstObject>())).last_sync as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(last_sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstObject>()))._gst_reserved as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstObject),
            "::",
            stringify!(_gst_reserved)
        )
    );
}
#[doc = " GstClockTime:"]
#[doc = ""]
#[doc = " A datatype to hold a time, measured in nanoseconds."]
pub type GstClockTime = guint64;
pub type GstMiniObject = _GstMiniObject;
#[doc = " GstMiniObjectCopyFunction:"]
#[doc = " @obj: MiniObject to copy"]
#[doc = ""]
#[doc = " Function prototype for methods to create copies of instances."]
#[doc = ""]
#[doc = " Returns: reference to cloned instance."]
pub type GstMiniObjectCopyFunction =
    ::std::option::Option<unsafe extern "C" fn(obj: *const GstMiniObject) -> *mut GstMiniObject>;
#[doc = " GstMiniObjectDisposeFunction:"]
#[doc = " @obj: MiniObject to dispose"]
#[doc = ""]
#[doc = " Function prototype for when a miniobject has lost its last refcount."]
#[doc = " Implementation of the mini object are allowed to revive the"]
#[doc = " passed object by doing a gst_mini_object_ref(). If the object is not"]
#[doc = " revived after the dispose function, the function should return %TRUE"]
#[doc = " and the memory associated with the object is freed."]
#[doc = ""]
#[doc = " Returns: %TRUE if the object should be cleaned up."]
pub type GstMiniObjectDisposeFunction =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut GstMiniObject) -> gboolean>;
#[doc = " GstMiniObjectFreeFunction:"]
#[doc = " @obj: MiniObject to free"]
#[doc = ""]
#[doc = " Virtual function prototype for methods to free resources used by"]
#[doc = " mini-objects."]
pub type GstMiniObjectFreeFunction =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut GstMiniObject)>;
#[doc = " GstMiniObject: (ref-func gst_mini_object_ref) (unref-func gst_mini_object_unref) (set-value-func g_value_set_boxed) (get-value-func g_value_get_boxed)"]
#[doc = " @type: the GType of the object"]
#[doc = " @refcount: atomic refcount"]
#[doc = " @lockstate: atomic state of the locks"]
#[doc = " @flags: extra flags."]
#[doc = " @copy: a copy function"]
#[doc = " @dispose: a dispose function"]
#[doc = " @free: the free function"]
#[doc = ""]
#[doc = " Base class for refcounted lightweight objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstMiniObject {
    pub type_: GType,
    pub refcount: gint,
    pub lockstate: gint,
    pub flags: guint,
    pub copy: GstMiniObjectCopyFunction,
    pub dispose: GstMiniObjectDisposeFunction,
    pub free: GstMiniObjectFreeFunction,
    pub priv_uint: guint,
    pub priv_pointer: gpointer,
}
#[test]
fn bindgen_test_layout__GstMiniObject() {
    assert_eq!(
        ::std::mem::size_of::<_GstMiniObject>(),
        64usize,
        concat!("Size of: ", stringify!(_GstMiniObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GstMiniObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GstMiniObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMiniObject>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMiniObject>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMiniObject>())).lockstate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(lockstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMiniObject>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMiniObject>())).copy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMiniObject>())).dispose as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(dispose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMiniObject>())).free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMiniObject>())).priv_uint as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(priv_uint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMiniObject>())).priv_pointer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMiniObject),
            "::",
            stringify!(priv_pointer)
        )
    );
}
pub type GstBuffer = _GstBuffer;
pub type GstBufferPool = _GstBufferPool;
pub type GstMeta = _GstMeta;
pub type GstMetaInfo = _GstMetaInfo;
pub const GstMetaFlags_GST_META_FLAG_NONE: GstMetaFlags = 0;
pub const GstMetaFlags_GST_META_FLAG_READONLY: GstMetaFlags = 1;
pub const GstMetaFlags_GST_META_FLAG_POOLED: GstMetaFlags = 2;
pub const GstMetaFlags_GST_META_FLAG_LOCKED: GstMetaFlags = 4;
pub const GstMetaFlags_GST_META_FLAG_LAST: GstMetaFlags = 65536;
#[doc = " GstMetaFlags:"]
#[doc = " @GST_META_FLAG_NONE: no flags"]
#[doc = " @GST_META_FLAG_READONLY: metadata should not be modified"]
#[doc = " @GST_META_FLAG_POOLED: metadata is managed by a bufferpool"]
#[doc = " @GST_META_FLAG_LOCKED: metadata should not be removed"]
#[doc = " @GST_META_FLAG_LAST: additional flags can be added starting from this flag."]
#[doc = ""]
#[doc = " Extra metadata flags."]
pub type GstMetaFlags = ::std::os::raw::c_uint;
#[doc = " GstMeta:"]
#[doc = " @flags: extra flags for the metadata"]
#[doc = " @info: pointer to the #GstMetaInfo"]
#[doc = ""]
#[doc = " Base structure for metadata. Custom metadata will put this structure"]
#[doc = " as the first member of their structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstMeta {
    pub flags: GstMetaFlags,
    pub info: *const GstMetaInfo,
}
#[test]
fn bindgen_test_layout__GstMeta() {
    assert_eq!(
        ::std::mem::size_of::<_GstMeta>(),
        16usize,
        concat!("Size of: ", stringify!(_GstMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_GstMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_GstMeta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMeta>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMeta),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMeta>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMeta),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " GstMetaInitFunction:"]
#[doc = " @meta: a #GstMeta"]
#[doc = " @params: parameters passed to the init function"]
#[doc = " @buffer: a #GstBuffer"]
#[doc = ""]
#[doc = " Function called when @meta is initialized in @buffer."]
pub type GstMetaInitFunction = ::std::option::Option<
    unsafe extern "C" fn(meta: *mut GstMeta, params: gpointer, buffer: *mut GstBuffer) -> gboolean,
>;
#[doc = " GstMetaFreeFunction:"]
#[doc = " @meta: a #GstMeta"]
#[doc = " @buffer: a #GstBuffer"]
#[doc = ""]
#[doc = " Function called when @meta is freed in @buffer."]
pub type GstMetaFreeFunction =
    ::std::option::Option<unsafe extern "C" fn(meta: *mut GstMeta, buffer: *mut GstBuffer)>;
#[doc = " GstMetaTransformFunction:"]
#[doc = " @transbuf: a #GstBuffer"]
#[doc = " @meta: a #GstMeta"]
#[doc = " @buffer: a #GstBuffer"]
#[doc = " @type: the transform type"]
#[doc = " @data: transform specific data."]
#[doc = ""]
#[doc = " Function called for each @meta in @buffer as a result of performing a"]
#[doc = " transformation on @transbuf. Additional @type specific transform data"]
#[doc = " is passed to the function as @data."]
#[doc = ""]
#[doc = " Implementations should check the @type of the transform and parse"]
#[doc = " additional type specific fields in @data that should be used to update"]
#[doc = " the metadata on @transbuf."]
#[doc = ""]
#[doc = " Returns: %TRUE if the transform could be performed"]
pub type GstMetaTransformFunction = ::std::option::Option<
    unsafe extern "C" fn(
        transbuf: *mut GstBuffer,
        meta: *mut GstMeta,
        buffer: *mut GstBuffer,
        type_: GQuark,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GstMetaInfo:"]
#[doc = " @api: tag identifying the metadata structure and api"]
#[doc = " @type: type identifying the implementor of the api"]
#[doc = " @size: size of the metadata"]
#[doc = " @init_func: function for initializing the metadata"]
#[doc = " @free_func: function for freeing the metadata"]
#[doc = " @transform_func: function for transforming the metadata"]
#[doc = ""]
#[doc = " The #GstMetaInfo provides information about a specific metadata"]
#[doc = " structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstMetaInfo {
    pub api: GType,
    pub type_: GType,
    pub size: gsize,
    pub init_func: GstMetaInitFunction,
    pub free_func: GstMetaFreeFunction,
    pub transform_func: GstMetaTransformFunction,
}
#[test]
fn bindgen_test_layout__GstMetaInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GstMetaInfo>(),
        48usize,
        concat!("Size of: ", stringify!(_GstMetaInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GstMetaInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GstMetaInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMetaInfo>())).api as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMetaInfo),
            "::",
            stringify!(api)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMetaInfo>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMetaInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMetaInfo>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMetaInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMetaInfo>())).init_func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMetaInfo),
            "::",
            stringify!(init_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMetaInfo>())).free_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMetaInfo),
            "::",
            stringify!(free_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstMetaInfo>())).transform_func as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstMetaInfo),
            "::",
            stringify!(transform_func)
        )
    );
}
#[doc = " GstBuffer:"]
#[doc = " @mini_object: the parent structure"]
#[doc = " @pool: pointer to the pool owner of the buffer"]
#[doc = " @pts: presentation timestamp of the buffer, can be #GST_CLOCK_TIME_NONE when the"]
#[doc = "     pts is not known or relevant. The pts contains the timestamp when the"]
#[doc = "     media should be presented to the user."]
#[doc = " @dts: decoding timestamp of the buffer, can be #GST_CLOCK_TIME_NONE when the"]
#[doc = "     dts is not known or relevant. The dts contains the timestamp when the"]
#[doc = "     media should be processed."]
#[doc = " @duration: duration in time of the buffer data, can be #GST_CLOCK_TIME_NONE"]
#[doc = "     when the duration is not known or relevant."]
#[doc = " @offset: a media specific offset for the buffer data."]
#[doc = "     For video frames, this is the frame number of this buffer."]
#[doc = "     For audio samples, this is the offset of the first sample in this buffer."]
#[doc = "     For file data or compressed data this is the byte offset of the first"]
#[doc = "       byte in this buffer."]
#[doc = " @offset_end: the last offset contained in this buffer. It has the same"]
#[doc = "     format as @offset."]
#[doc = ""]
#[doc = " The structure of a #GstBuffer. Use the associated macros to access the public"]
#[doc = " variables."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBuffer {
    pub mini_object: GstMiniObject,
    pub pool: *mut GstBufferPool,
    pub pts: GstClockTime,
    pub dts: GstClockTime,
    pub duration: GstClockTime,
    pub offset: guint64,
    pub offset_end: guint64,
}
#[test]
fn bindgen_test_layout__GstBuffer() {
    assert_eq!(
        ::std::mem::size_of::<_GstBuffer>(),
        112usize,
        concat!("Size of: ", stringify!(_GstBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_GstBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_GstBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstBuffer>())).mini_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(mini_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstBuffer>())).pool as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstBuffer>())).pts as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstBuffer>())).dts as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstBuffer>())).duration as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstBuffer>())).offset as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstBuffer>())).offset_end as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBuffer),
            "::",
            stringify!(offset_end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GstBufferPoolPrivate {
    _unused: [u8; 0],
}
pub type GstBufferPoolPrivate = _GstBufferPoolPrivate;
#[doc = " GstBufferPool:"]
#[doc = ""]
#[doc = " The structure of a #GstBufferPool. Use the associated macros to access the public"]
#[doc = " variables."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GstBufferPool {
    pub object: GstObject,
    pub flushing: gint,
    pub priv_: *mut GstBufferPoolPrivate,
    pub _gst_reserved: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GstBufferPool() {
    assert_eq!(
        ::std::mem::size_of::<_GstBufferPool>(),
        136usize,
        concat!("Size of: ", stringify!(_GstBufferPool))
    );
    assert_eq!(
        ::std::mem::align_of::<_GstBufferPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_GstBufferPool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstBufferPool>())).object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBufferPool),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstBufferPool>())).flushing as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBufferPool),
            "::",
            stringify!(flushing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstBufferPool>())).priv_ as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBufferPool),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GstBufferPool>()))._gst_reserved as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GstBufferPool),
            "::",
            stringify!(_gst_reserved)
        )
    );
}
#[doc = " Specifies an arrow head only at start = 0."]
pub const NvOSD_Arrow_Head_Direction_START_HEAD: NvOSD_Arrow_Head_Direction = 0;
#[doc = " Specifies an arrow head only at end = 1."]
pub const NvOSD_Arrow_Head_Direction_END_HEAD: NvOSD_Arrow_Head_Direction = 1;
#[doc = " Specifies arrow heads at both start and end = 2."]
pub const NvOSD_Arrow_Head_Direction_BOTH_HEAD: NvOSD_Arrow_Head_Direction = 2;
#[doc = " Specifies arrow head positions."]
pub type NvOSD_Arrow_Head_Direction = ::std::os::raw::c_uint;
#[doc = " Holds unclipped bounding box coordinates of the object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvBbox_Coords {
    #[doc = "< Holds the box's left coordinate"]
    #[doc = "in pixels."]
    pub left: f32,
    #[doc = "< Holds the box's top coordinate"]
    #[doc = "in pixels."]
    pub top: f32,
    #[doc = "< Holds the box's width in pixels."]
    pub width: f32,
    #[doc = "< Holds the box's height in pixels."]
    pub height: f32,
}
#[test]
fn bindgen_test_layout__NvBbox_Coords() {
    assert_eq!(
        ::std::mem::size_of::<_NvBbox_Coords>(),
        16usize,
        concat!("Size of: ", stringify!(_NvBbox_Coords))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvBbox_Coords>(),
        4usize,
        concat!("Alignment of ", stringify!(_NvBbox_Coords))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvBbox_Coords>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvBbox_Coords),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvBbox_Coords>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvBbox_Coords),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvBbox_Coords>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvBbox_Coords),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvBbox_Coords>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvBbox_Coords),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Holds unclipped bounding box coordinates of the object."]
pub type NvBbox_Coords = _NvBbox_Coords;
#[doc = " Holds the color parameters of the box or text to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_ColorParams {
    #[doc = "< Holds the red component of color."]
    #[doc = "Value must be in the range 0.0-1.0."]
    pub red: f64,
    #[doc = "< Holds the green component of color."]
    #[doc = "Value must be in the range 0.0-1.0."]
    pub green: f64,
    #[doc = "< Holds the blue component of color."]
    #[doc = "Value must be in the range 0.0-1.0."]
    pub blue: f64,
    #[doc = "< Holds the alpha component of color."]
    #[doc = "Value must be in the range 0.0-1.0."]
    pub alpha: f64,
}
#[test]
fn bindgen_test_layout__NvOSD_ColorParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_ColorParams>(),
        32usize,
        concat!("Size of: ", stringify!(_NvOSD_ColorParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_ColorParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_ColorParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_ColorParams>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ColorParams),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_ColorParams>())).green as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ColorParams),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_ColorParams>())).blue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ColorParams),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_ColorParams>())).alpha as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ColorParams),
            "::",
            stringify!(alpha)
        )
    );
}
#[doc = " Holds the color parameters of the box or text to be overlayed."]
pub type NvOSD_ColorParams = _NvOSD_ColorParams;
#[doc = " Holds the font parameters of the text to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_FontParams {
    #[doc = "< Holds a pointer to the string containing"]
    #[doc = "the font name. To display a list of"]
    #[doc = "supported fonts, run the fc-list command."]
    pub font_name: *mut ::std::os::raw::c_char,
    #[doc = "< Holds the size of the font."]
    pub font_size: ::std::os::raw::c_uint,
    #[doc = "< Holds the font color."]
    pub font_color: NvOSD_ColorParams,
}
#[test]
fn bindgen_test_layout__NvOSD_FontParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_FontParams>(),
        48usize,
        concat!("Size of: ", stringify!(_NvOSD_FontParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_FontParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_FontParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_FontParams>())).font_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_FontParams),
            "::",
            stringify!(font_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_FontParams>())).font_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_FontParams),
            "::",
            stringify!(font_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_FontParams>())).font_color as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_FontParams),
            "::",
            stringify!(font_color)
        )
    );
}
#[doc = " Holds the font parameters of the text to be overlayed."]
pub type NvOSD_FontParams = _NvOSD_FontParams;
#[doc = " Holds parameters of text to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_TextParams {
    #[doc = "< Holds the text to be overlayed."]
    pub display_text: *mut ::std::os::raw::c_char,
    #[doc = "< Holds the text's horizontal offset from"]
    #[doc = "the top left pixel of the frame."]
    pub x_offset: ::std::os::raw::c_uint,
    #[doc = "< Holds the text's vertical offset from the"]
    #[doc = "top left pixel of the frame."]
    pub y_offset: ::std::os::raw::c_uint,
    #[doc = "< Holds the font parameters of the text"]
    #[doc = "to be overlaid."]
    pub font_params: NvOSD_FontParams,
    #[doc = "< Holds a Boolean; true if the text has a"]
    #[doc = "background color."]
    pub set_bg_clr: ::std::os::raw::c_int,
    #[doc = "< Holds the text's background color, if"]
    #[doc = "specified."]
    pub text_bg_clr: NvOSD_ColorParams,
}
#[test]
fn bindgen_test_layout__NvOSD_TextParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_TextParams>(),
        104usize,
        concat!("Size of: ", stringify!(_NvOSD_TextParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_TextParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_TextParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_TextParams>())).display_text as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_TextParams),
            "::",
            stringify!(display_text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_TextParams>())).x_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_TextParams),
            "::",
            stringify!(x_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_TextParams>())).y_offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_TextParams),
            "::",
            stringify!(y_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_TextParams>())).font_params as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_TextParams),
            "::",
            stringify!(font_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_TextParams>())).set_bg_clr as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_TextParams),
            "::",
            stringify!(set_bg_clr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_TextParams>())).text_bg_clr as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_TextParams),
            "::",
            stringify!(text_bg_clr)
        )
    );
}
#[doc = " Holds parameters of text to be overlayed."]
pub type NvOSD_TextParams = _NvOSD_TextParams;
#[doc = " Holds the box parameters of the box to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_RectParams {
    #[doc = "< Holds the box's left coordinate"]
    #[doc = "in pixels."]
    pub left: f32,
    #[doc = "< Holds the box's top coordinate"]
    #[doc = "in pixels."]
    pub top: f32,
    #[doc = "< Holds the box's width in pixels."]
    pub width: f32,
    #[doc = "< Holds the box's height in pixels."]
    pub height: f32,
    #[doc = "< Holds the box's border width in pixels."]
    pub border_width: ::std::os::raw::c_uint,
    pub border_color: NvOSD_ColorParams,
    #[doc = "< Holds a Boolean; true if the box has a"]
    #[doc = "background color."]
    pub has_bg_color: ::std::os::raw::c_uint,
    #[doc = "< Holds a field reserved for future use."]
    pub reserved: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's background color."]
    pub bg_color: NvOSD_ColorParams,
    pub has_color_info: ::std::os::raw::c_int,
    pub color_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__NvOSD_RectParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_RectParams>(),
        104usize,
        concat!("Size of: ", stringify!(_NvOSD_RectParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_RectParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_RectParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_RectParams>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_RectParams>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_RectParams>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_RectParams>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_RectParams>())).border_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_RectParams>())).border_color as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(border_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_RectParams>())).has_bg_color as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(has_bg_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_RectParams>())).reserved as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_RectParams>())).bg_color as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(bg_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvOSD_RectParams>())).has_color_info as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(has_color_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_RectParams>())).color_id as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_RectParams),
            "::",
            stringify!(color_id)
        )
    );
}
#[doc = " Holds the box parameters of the box to be overlayed."]
pub type NvOSD_RectParams = _NvOSD_RectParams;
#[doc = " Holds the mask parameters of the segment to be overlayed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_MaskParams {
    pub data: *mut f32,
    #[doc = " Mask data"]
    pub size: ::std::os::raw::c_uint,
    #[doc = " Mask size"]
    pub threshold: f32,
    #[doc = " Threshold for binarization"]
    pub width: ::std::os::raw::c_uint,
    #[doc = " Mask width"]
    pub height: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__NvOSD_MaskParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_MaskParams>(),
        24usize,
        concat!("Size of: ", stringify!(_NvOSD_MaskParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_MaskParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_MaskParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_MaskParams>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_MaskParams),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_MaskParams>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_MaskParams),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_MaskParams>())).threshold as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_MaskParams),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_MaskParams>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_MaskParams),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_MaskParams>())).height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_MaskParams),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Holds the mask parameters of the segment to be overlayed"]
pub type NvOSD_MaskParams = _NvOSD_MaskParams;
#[doc = " Holds the box parameters of a line to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_LineParams {
    #[doc = "< Holds the box's left coordinate"]
    #[doc = "in pixels."]
    pub x1: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's top coordinate"]
    #[doc = "in pixels."]
    pub y1: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's width in pixels."]
    pub x2: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's height in pixels."]
    pub y2: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's border width in pixels."]
    pub line_width: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's border color."]
    pub line_color: NvOSD_ColorParams,
}
#[test]
fn bindgen_test_layout__NvOSD_LineParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_LineParams>(),
        56usize,
        concat!("Size of: ", stringify!(_NvOSD_LineParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_LineParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_LineParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_LineParams>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_LineParams),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_LineParams>())).y1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_LineParams),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_LineParams>())).x2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_LineParams),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_LineParams>())).y2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_LineParams),
            "::",
            stringify!(y2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_LineParams>())).line_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_LineParams),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_LineParams>())).line_color as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_LineParams),
            "::",
            stringify!(line_color)
        )
    );
}
#[doc = " Holds the box parameters of a line to be overlayed."]
pub type NvOSD_LineParams = _NvOSD_LineParams;
#[doc = " Holds arrow parameters to be overlaid."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_ArrowParams {
    #[doc = "< Holds the start horizontal coordinate in pixels."]
    pub x1: ::std::os::raw::c_uint,
    #[doc = "< Holds the start vertical coordinate in pixels."]
    pub y1: ::std::os::raw::c_uint,
    #[doc = "< Holds the end horizontal coordinate in pixels."]
    pub x2: ::std::os::raw::c_uint,
    #[doc = "< Holds the end vertical coordinate in pixels."]
    pub y2: ::std::os::raw::c_uint,
    #[doc = "< Holds the arrow shaft width in pixels."]
    pub arrow_width: ::std::os::raw::c_uint,
    pub arrow_head: NvOSD_Arrow_Head_Direction,
    pub arrow_color: NvOSD_ColorParams,
    #[doc = "< Reserved for future use; currently"]
    #[doc = "for internal use only."]
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__NvOSD_ArrowParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_ArrowParams>(),
        64usize,
        concat!("Size of: ", stringify!(_NvOSD_ArrowParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_ArrowParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_ArrowParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_ArrowParams>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_ArrowParams>())).y1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_ArrowParams>())).x2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_ArrowParams>())).y2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(y2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_ArrowParams>())).arrow_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(arrow_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_ArrowParams>())).arrow_head as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(arrow_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_ArrowParams>())).arrow_color as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(arrow_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_ArrowParams>())).reserved as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_ArrowParams),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds arrow parameters to be overlaid."]
pub type NvOSD_ArrowParams = _NvOSD_ArrowParams;
#[doc = " Holds circle parameters to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_CircleParams {
    #[doc = "< Holds the start horizontal coordinate in pixels."]
    pub xc: ::std::os::raw::c_uint,
    #[doc = "< Holds the start vertical coordinate in pixels."]
    pub yc: ::std::os::raw::c_uint,
    #[doc = "< Holds the radius of circle in pixels."]
    pub radius: ::std::os::raw::c_uint,
    pub circle_color: NvOSD_ColorParams,
    pub has_bg_color: ::std::os::raw::c_uint,
    pub bg_color: NvOSD_ColorParams,
    #[doc = "< Reserved for future use; currently"]
    #[doc = "for internal use only."]
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__NvOSD_CircleParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_CircleParams>(),
        96usize,
        concat!("Size of: ", stringify!(_NvOSD_CircleParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_CircleParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_CircleParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_CircleParams>())).xc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(xc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_CircleParams>())).yc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(yc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_CircleParams>())).radius as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(radius)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvOSD_CircleParams>())).circle_color as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(circle_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvOSD_CircleParams>())).has_bg_color as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(has_bg_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_CircleParams>())).bg_color as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(bg_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvOSD_CircleParams>())).reserved as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvOSD_CircleParams),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds circle parameters to be overlayed."]
pub type NvOSD_CircleParams = _NvOSD_CircleParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufSurfaceParams {
    _unused: [u8; 0],
}
#[doc = " DS NvDsFrameMeta"]
pub type NvDsFrameMeta = _NvDsFrameMeta;
#[doc = " classifier meta list"]
pub type NvDsClassifierMetaList = GList;
#[doc = " user meta list"]
pub type NvDsUserMetaList = GList;
#[doc = " Holds Information about ROI Metadata"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsRoiMeta {
    pub roi: NvOSD_RectParams,
    #[doc = " currently not being used"]
    pub roi_polygon: [[guint; 2usize]; 8usize],
    pub converted_buffer: *mut NvBufSurfaceParams,
    pub frame_meta: *mut NvDsFrameMeta,
    #[doc = " Ratio by which the frame/ROI crop was scaled in horizontal direction"]
    #[doc = " Required when scaling co-ordinates/sizes in metadata"]
    #[doc = " back to input resolution."]
    pub scale_ratio_x: gdouble,
    #[doc = " Ratio by which the frame/ROI crop was scaled in vertical direction"]
    #[doc = " Required when scaling co-ordinates/sizes in metadata"]
    #[doc = " back to input resolution."]
    pub scale_ratio_y: gdouble,
    #[doc = " offsets in horizontal direction while scaling"]
    pub offset_left: gdouble,
    #[doc = " offsets in vertical direction while scaling"]
    pub offset_top: gdouble,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsClassifierMeta."]
    pub classifier_meta_list: *mut NvDsClassifierMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta."]
    pub roi_user_meta_list: *mut NvDsUserMetaList,
}
#[test]
fn bindgen_test_layout_NvDsRoiMeta() {
    assert_eq!(
        ::std::mem::size_of::<NvDsRoiMeta>(),
        232usize,
        concat!("Size of: ", stringify!(NvDsRoiMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsRoiMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsRoiMeta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsRoiMeta>())).roi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(roi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsRoiMeta>())).roi_polygon as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(roi_polygon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsRoiMeta>())).converted_buffer as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(converted_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsRoiMeta>())).frame_meta as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(frame_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsRoiMeta>())).scale_ratio_x as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(scale_ratio_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsRoiMeta>())).scale_ratio_y as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(scale_ratio_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsRoiMeta>())).offset_left as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(offset_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsRoiMeta>())).offset_top as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(offset_top)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NvDsRoiMeta>())).classifier_meta_list as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(classifier_meta_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsRoiMeta>())).roi_user_meta_list as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsRoiMeta),
            "::",
            stringify!(roi_user_meta_list)
        )
    );
}
pub type NvDsFrameMetaList = GList;
pub type NvDsObjectMetaList = GList;
pub type NvDisplayMetaList = GList;
pub type NvDsLabelInfoList = GList;
pub type NvDsMetaList = GList;
#[doc = " \\brief  Defines the type of a callback to copy metadata."]
#[doc = ""]
#[doc = " The callback is passed pointers to source metadata. It allocates the"]
#[doc = " required memory, copies the content from the source metadata and returns"]
#[doc = " a pointer to the destination."]
#[doc = ""]
#[doc = " @param[in]  data         A pointer to the source metadata."]
#[doc = " @param[in]  user_data    A pointer to user-specific data."]
pub type NvDsMetaCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
#[doc = " \\brief  Defines the type of a callback to free metadata."]
#[doc = ""]
#[doc = " The callback is passed a pointer to metadata created by NvDsMetaCopyFunc()."]
#[doc = " It frees the metadata and"]
#[doc = " any other resources that the metadata uses."]
#[doc = ""]
#[doc = " @param[in]  data         A pointer to the metadata to be freed."]
#[doc = " @param[in]  user_data    A pointer to user-specific data."]
pub type NvDsMetaReleaseFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub const NvDsMetaType_NVDS_INVALID_META: NvDsMetaType = -1;
#[doc = " Specifies metadata type for formed batch."]
pub const NvDsMetaType_NVDS_BATCH_META: NvDsMetaType = 1;
#[doc = " Specifies metadata type for frame."]
pub const NvDsMetaType_NVDS_FRAME_META: NvDsMetaType = 2;
#[doc = " Specifies metadata type for a detected object."]
pub const NvDsMetaType_NVDS_OBJ_META: NvDsMetaType = 3;
#[doc = " Specifies metadata type for display."]
pub const NvDsMetaType_NVDS_DISPLAY_META: NvDsMetaType = 4;
#[doc = " Specifies metadata type for an object classifier."]
pub const NvDsMetaType_NVDS_CLASSIFIER_META: NvDsMetaType = 5;
#[doc = " Specifies metadata type for a label assigned by a classifier."]
pub const NvDsMetaType_NVDS_LABEL_INFO_META: NvDsMetaType = 6;
#[doc = " Reserved for internal use."]
pub const NvDsMetaType_NVDS_USER_META: NvDsMetaType = 7;
#[doc = " Specifies metadata type for a payload generated by a message converter."]
pub const NvDsMetaType_NVDS_PAYLOAD_META: NvDsMetaType = 8;
#[doc = " Specifies metadata type for a payload generated by a message broker."]
pub const NvDsMetaType_NVDS_EVENT_MSG_META: NvDsMetaType = 9;
#[doc = " Specifies metadata type for an optical flow."]
pub const NvDsMetaType_NVDS_OPTICAL_FLOW_META: NvDsMetaType = 10;
#[doc = " Specifies metadata type for a latency measurement."]
pub const NvDsMetaType_NVDS_LATENCY_MEASUREMENT_META: NvDsMetaType = 11;
#[doc = " Specifies metadata type for raw inference output attached by Gst-nvinfer."]
#[doc = "@see NvDsInferTensorMeta for details."]
pub const NvDsMetaType_NVDSINFER_TENSOR_OUTPUT_META: NvDsMetaType = 12;
#[doc = " Specifies metadata type for segmentation model output attached by"]
#[doc = "Gst-nvinfer. @see NvDsInferSegmentationMeta for details."]
pub const NvDsMetaType_NVDSINFER_SEGMENTATION_META: NvDsMetaType = 13;
#[doc = " Specifies metadata type for JPEG-encoded object crops."]
#[doc = " See the deepstream-image-meta-test app for details."]
pub const NvDsMetaType_NVDS_CROP_IMAGE_META: NvDsMetaType = 14;
#[doc = " metadata type to be set for tracking previous frames"]
pub const NvDsMetaType_NVDS_TRACKER_PAST_FRAME_META: NvDsMetaType = 15;
#[doc = " Specifies metadata type for formed audio batch."]
pub const NvDsMetaType_NVDS_AUDIO_BATCH_META: NvDsMetaType = 16;
#[doc = " Specifies metadata type for audio frame."]
pub const NvDsMetaType_NVDS_AUDIO_FRAME_META: NvDsMetaType = 17;
#[doc = " Specifies metadata type for preprocess scale&converted ROIs attached by Gst-nvdspreprocess."]
#[doc = "@see NvDsPreProcessFrameMeta for details."]
pub const NvDsMetaType_NVDS_PREPROCESS_FRAME_META: NvDsMetaType = 18;
#[doc = " Specifies metadata type for preprocess batch level attached by Gst-nvdspreprocess."]
#[doc = "@see NvDsPreProcessBatchMeta for details."]
pub const NvDsMetaType_NVDS_PREPROCESS_BATCH_META: NvDsMetaType = 19;
#[doc = " Specifies user defined custom message blob to be part of payload generated"]
pub const NvDsMetaType_NVDS_CUSTOM_MSG_BLOB: NvDsMetaType = 20;
#[doc = " Reserved field"]
pub const NvDsMetaType_NVDS_RESERVED_META: NvDsMetaType = 4095;
#[doc = " Specifies the start of a range of enum values that represent types of"]
#[doc = " NVIDIA-defined Gst metas. The range is from NVDS_GST_CUSTOM_META to"]
#[doc = " NVDS_GST_CUSTOM_META+4096, inclusive."]
pub const NvDsMetaType_NVDS_GST_CUSTOM_META: NvDsMetaType = 4096;
#[doc = " Start adding user specific meta types from here */"]
#[doc = " Specifies the start of a range of enum values that represent custom"]
#[doc = " (application-specific) Gst meta types. A custom meta type may be assigned"]
#[doc = " any enum value equal to or larger than this."]
#[doc = ""]
#[doc = " Such Gst metas may be attached by GStreamer plugins upstream from"]
#[doc = " Gst-nvstreammux. They may have any contents that is a superset of"]
#[doc = " the metadata in an @ref NvDsFrameMeta."]
pub const NvDsMetaType_NVDS_START_USER_META: NvDsMetaType = 8193;
#[doc = " Start adding user specific meta types from here */"]
#[doc = " Specifies the start of a range of enum values that represent custom"]
#[doc = " (application-specific) Gst meta types. A custom meta type may be assigned"]
#[doc = " any enum value equal to or larger than this."]
#[doc = ""]
#[doc = " Such Gst metas may be attached by GStreamer plugins upstream from"]
#[doc = " Gst-nvstreammux. They may have any contents that is a superset of"]
#[doc = " the metadata in an @ref NvDsFrameMeta."]
pub const NvDsMetaType_NVDS_FORCE32_META: NvDsMetaType = 2147483647;
#[doc = " Specifies the type of metadata. All metadata types are subtypes of"]
#[doc = " @ref NvDsMetaType. Members that represent NVIDIA-defined types are"]
#[doc = " in the range from @ref NVDS_BATCH_META to @ref NVDS_START_USER_META."]
#[doc = " User-defined types may be assigned values greater than or equal to"]
#[doc = " @ref NVDS_START_USER_META."]
pub type NvDsMetaType = ::std::os::raw::c_int;
#[doc = " Holds unclipped positional bounding box coordinates of the object processed"]
#[doc = " by the component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsComp_BboxInfo {
    pub org_bbox_coords: NvBbox_Coords,
}
#[test]
fn bindgen_test_layout__NvDsComp_BboxInfo() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsComp_BboxInfo>(),
        16usize,
        concat!("Size of: ", stringify!(_NvDsComp_BboxInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsComp_BboxInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(_NvDsComp_BboxInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsComp_BboxInfo>())).org_bbox_coords as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsComp_BboxInfo),
            "::",
            stringify!(org_bbox_coords)
        )
    );
}
#[doc = " Holds unclipped positional bounding box coordinates of the object processed"]
#[doc = " by the component."]
pub type NvDsComp_BboxInfo = _NvDsComp_BboxInfo;
#[doc = " Holds information about a given metadata pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsMetaPool {
    pub meta_type: NvDsMetaType,
    pub max_elements_in_pool: guint,
    pub element_size: guint,
    pub num_empty_elements: guint,
    pub num_full_elements: guint,
    pub empty_list: *mut NvDsMetaList,
    pub full_list: *mut NvDsMetaList,
    pub copy_func: NvDsMetaCopyFunc,
    pub release_func: NvDsMetaReleaseFunc,
}
#[test]
fn bindgen_test_layout__NvDsMetaPool() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsMetaPool>(),
        56usize,
        concat!("Size of: ", stringify!(_NvDsMetaPool))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsMetaPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsMetaPool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMetaPool>())).meta_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(meta_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsMetaPool>())).max_elements_in_pool as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(max_elements_in_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMetaPool>())).element_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(element_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsMetaPool>())).num_empty_elements as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(num_empty_elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMetaPool>())).num_full_elements as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(num_full_elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMetaPool>())).empty_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(empty_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMetaPool>())).full_list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(full_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMetaPool>())).copy_func as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(copy_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMetaPool>())).release_func as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMetaPool),
            "::",
            stringify!(release_func)
        )
    );
}
#[doc = " Holds information about a given metadata pool."]
pub type NvDsMetaPool = _NvDsMetaPool;
#[doc = " Holds information about base metadata of a given metadata type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsBaseMeta {
    #[doc = " Holds a pointer to batch_meta @ref NvDsBatchMeta."]
    pub batch_meta: *mut _NvDsBatchMeta,
    #[doc = " Holds the metadata type of this metadata element."]
    pub meta_type: NvDsMetaType,
    #[doc = " Holds a pointer to a user context."]
    pub uContext: *mut ::std::os::raw::c_void,
    #[doc = " Holds a user-defined copy function. The function is called to copy"]
    #[doc = "or transform metadata from one buffer to another. @a meta_data and"]
    #[doc = "@a user_data are passed as arguments."]
    pub copy_func: NvDsMetaCopyFunc,
    #[doc = " Holds a user-defined release function. The function is called"]
    #[doc = "when @a meta_data is to be released."]
    pub release_func: NvDsMetaReleaseFunc,
}
#[test]
fn bindgen_test_layout__NvDsBaseMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsBaseMeta>(),
        40usize,
        concat!("Size of: ", stringify!(_NvDsBaseMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsBaseMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsBaseMeta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBaseMeta>())).batch_meta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBaseMeta),
            "::",
            stringify!(batch_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBaseMeta>())).meta_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBaseMeta),
            "::",
            stringify!(meta_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBaseMeta>())).uContext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBaseMeta),
            "::",
            stringify!(uContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBaseMeta>())).copy_func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBaseMeta),
            "::",
            stringify!(copy_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBaseMeta>())).release_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBaseMeta),
            "::",
            stringify!(release_func)
        )
    );
}
#[doc = " Holds information about base metadata of a given metadata type."]
pub type NvDsBaseMeta = _NvDsBaseMeta;
#[doc = " Holds information about a formed batch containing frames from different"]
#[doc = " sources."]
#[doc = " NOTE: Both Video and Audio metadata uses the same NvDsBatchMeta type."]
#[doc = " NOTE: Audio batch metadata is formed within nvinferaudio plugin"]
#[doc = " and will not be corresponding to any one buffer output from nvinferaudio."]
#[doc = " The NvDsBatchMeta for audio is attached to the last input buffer"]
#[doc = " when the audio batch buffering reach configurable threshold"]
#[doc = " (audio frame length) and this is when inference output is available."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsBatchMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the maximum number of frames in the batch."]
    pub max_frames_in_batch: guint,
    #[doc = " Holds the number of frames now in the batch."]
    pub num_frames_in_batch: guint,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsFrameMeta,"]
    #[doc = "representing a pool of frame metas."]
    pub frame_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type NvDsObjMeta,"]
    #[doc = "representing a pool of object metas."]
    pub obj_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsClassifierMeta,"]
    #[doc = "representing a pool of classifier metas."]
    pub classifier_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsDisplayMeta,"]
    #[doc = "representing a pool of display metas."]
    pub display_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsUserMeta,"]
    #[doc = "representing a pool of user metas."]
    pub user_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsLabelInfo,"]
    #[doc = "representing a pool of label metas."]
    pub label_info_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a list of pointers of type NvDsFrameMeta"]
    #[doc = "or NvDsAudioFrameMeta (when the batch represent audio batch),"]
    #[doc = "representing frame metas used in the current batch."]
    pub frame_meta_list: *mut NvDsFrameMetaList,
    #[doc = " Holds a pointer to a list of pointers of type NvDsUserMeta,"]
    #[doc = "representing user metas in the current batch."]
    pub batch_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds a lock to be set before accessing metadata to avoid"]
    #[doc = "simultaneous update by multiple components."]
    pub meta_mutex: GRecMutex,
    #[doc = " Holds an array of user-specific batch information."]
    pub misc_batch_info: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout__NvDsBatchMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsBatchMeta>(),
        192usize,
        concat!("Size of: ", stringify!(_NvDsBatchMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsBatchMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsBatchMeta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBatchMeta>())).base_meta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsBatchMeta>())).max_frames_in_batch as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(max_frames_in_batch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsBatchMeta>())).num_frames_in_batch as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(num_frames_in_batch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBatchMeta>())).frame_meta_pool as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(frame_meta_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBatchMeta>())).obj_meta_pool as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(obj_meta_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsBatchMeta>())).classifier_meta_pool as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(classifier_meta_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsBatchMeta>())).display_meta_pool as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(display_meta_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBatchMeta>())).user_meta_pool as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(user_meta_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsBatchMeta>())).label_info_meta_pool as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(label_info_meta_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBatchMeta>())).frame_meta_list as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(frame_meta_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsBatchMeta>())).batch_user_meta_list as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(batch_user_meta_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBatchMeta>())).meta_mutex as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(meta_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBatchMeta>())).misc_batch_info as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(misc_batch_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsBatchMeta>())).reserved as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsBatchMeta),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds information about a formed batch containing frames from different"]
#[doc = " sources."]
#[doc = " NOTE: Both Video and Audio metadata uses the same NvDsBatchMeta type."]
#[doc = " NOTE: Audio batch metadata is formed within nvinferaudio plugin"]
#[doc = " and will not be corresponding to any one buffer output from nvinferaudio."]
#[doc = " The NvDsBatchMeta for audio is attached to the last input buffer"]
#[doc = " when the audio batch buffering reach configurable threshold"]
#[doc = " (audio frame length) and this is when inference output is available."]
pub type NvDsBatchMeta = _NvDsBatchMeta;
#[doc = " Holds metadata for a frame in a batch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsFrameMeta {
    #[doc = " Holds the base metadata for the frame."]
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the pad or port index of the Gst-streammux plugin for the frame"]
    #[doc = "in the batch."]
    pub pad_index: guint,
    #[doc = " Holds the location of the frame in the batch. The frame's"]
    #[doc = "@ref NvBufSurfaceParams are at index @a batch_id in the @a surfaceList"]
    #[doc = "array of @ref NvBufSurface."]
    pub batch_id: guint,
    #[doc = " Holds the current frame number of the source."]
    pub frame_num: gint,
    #[doc = " Holds the presentation timestamp (PTS) of the frame."]
    pub buf_pts: guint64,
    #[doc = " Holds the ntp timestamp."]
    pub ntp_timestamp: guint64,
    #[doc = " Holds the source IDof the frame in the batch, e.g. the camera ID."]
    #[doc = "It need not be in sequential order."]
    pub source_id: guint,
    #[doc = " Holds the number of surfaces in the frame, required in case of"]
    #[doc = "multiple surfaces in the frame."]
    pub num_surfaces_per_frame: gint,
    pub source_frame_width: guint,
    pub source_frame_height: guint,
    pub surface_type: guint,
    pub surface_index: guint,
    #[doc = " Holds the number of object meta elements attached to current frame."]
    pub num_obj_meta: guint,
    #[doc = " Holds a Boolean indicating whether inference is performed on the frame."]
    pub bInferDone: gboolean,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsObjectMeta"]
    #[doc = "in use for the frame."]
    pub obj_meta_list: *mut NvDsObjectMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsDisplayMeta"]
    #[doc = "in use for the frame."]
    pub display_meta_list: *mut NvDisplayMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta"]
    #[doc = "in use for the frame."]
    pub frame_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds additional user-defined frame information."]
    pub misc_frame_info: [gint64; 4usize],
    pub pipeline_width: guint,
    pub pipeline_height: guint,
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout__NvDsFrameMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsFrameMeta>(),
        200usize,
        concat!("Size of: ", stringify!(_NvDsFrameMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsFrameMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsFrameMeta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).base_meta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).pad_index as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(pad_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).batch_id as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(batch_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).frame_num as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(frame_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).buf_pts as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(buf_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).ntp_timestamp as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(ntp_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).source_id as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsFrameMeta>())).num_surfaces_per_frame as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(num_surfaces_per_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsFrameMeta>())).source_frame_width as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(source_frame_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsFrameMeta>())).source_frame_height as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(source_frame_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).surface_type as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(surface_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).surface_index as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(surface_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).num_obj_meta as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(num_obj_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).bInferDone as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(bInferDone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).obj_meta_list as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(obj_meta_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsFrameMeta>())).display_meta_list as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(display_meta_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsFrameMeta>())).frame_user_meta_list as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(frame_user_meta_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).misc_frame_info as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(misc_frame_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).pipeline_width as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(pipeline_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).pipeline_height as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(pipeline_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsFrameMeta>())).reserved as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsFrameMeta),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds metadata for an object in the frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsObjectMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds a pointer to the parent @ref NvDsObjectMeta. Set to NULL if"]
    #[doc = "no parent exists."]
    pub parent: *mut _NvDsObjectMeta,
    #[doc = " Holds a unique component ID that identifies the metadata"]
    #[doc = "in this structure."]
    pub unique_component_id: gint,
    #[doc = " Holds the index of the object class inferred by the primary"]
    #[doc = "detector/classifier."]
    pub class_id: gint,
    #[doc = " Holds a unique ID for tracking the object. @ref UNTRACKED_OBJECT_ID"]
    #[doc = "indicates that the object has not been tracked."]
    pub object_id: guint64,
    #[doc = " Holds a structure containing bounding box parameters of the object when"]
    #[doc = "detected by detector."]
    pub detector_bbox_info: NvDsComp_BboxInfo,
    #[doc = " Holds a structure containing bounding box coordinates of the object when"]
    #[doc = " processed by tracker."]
    pub tracker_bbox_info: NvDsComp_BboxInfo,
    #[doc = " Holds a confidence value for the object, set by the inference"]
    #[doc = "component. confidence will be set to -0.1, if \"Group Rectangles\" mode of"]
    #[doc = "clustering is chosen since the algorithm does not preserve confidence"]
    #[doc = "values. Also, for objects found by tracker and not inference component,"]
    #[doc = "confidence will be set to -0.1"]
    pub confidence: gfloat,
    #[doc = " Holds a confidence value for the object set by nvdcf_tracker."]
    #[doc = " tracker_confidence will be set to -0.1 for KLT and IOU tracker"]
    pub tracker_confidence: gfloat,
    #[doc = " Holds a structure containing positional parameters of the object"]
    #[doc = " processed by the last component that updates it in the pipeline."]
    #[doc = " e.g. If the tracker component is after the detector component in the"]
    #[doc = " pipeline then positinal parameters are from tracker component."]
    #[doc = " Positional parameters are clipped so that they do not fall outside frame"]
    #[doc = " boundary. Can also be used to overlay borders or semi-transparent boxes on"]
    #[doc = " objects. @see NvOSD_RectParams."]
    pub rect_params: NvOSD_RectParams,
    #[doc = " Holds mask parameters for the object. This mask is overlayed on object"]
    #[doc = " @see NvOSD_MaskParams."]
    pub mask_params: NvOSD_MaskParams,
    #[doc = " Holds text describing the object. This text can be overlayed on the"]
    #[doc = "standard text that identifies the object. @see NvOSD_TextParams."]
    pub text_params: NvOSD_TextParams,
    #[doc = " Holds a string describing the class of the detected object."]
    pub obj_label: [gchar; 128usize],
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsClassifierMeta."]
    pub classifier_meta_list: *mut NvDsClassifierMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta."]
    pub obj_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds additional user-defined object information."]
    pub misc_obj_info: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout__NvDsObjectMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsObjectMeta>(),
        544usize,
        concat!("Size of: ", stringify!(_NvDsObjectMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsObjectMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsObjectMeta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsObjectMeta>())).base_meta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsObjectMeta>())).parent as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsObjectMeta>())).unique_component_id as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(unique_component_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsObjectMeta>())).class_id as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(class_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsObjectMeta>())).object_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(object_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsObjectMeta>())).detector_bbox_info as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(detector_bbox_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsObjectMeta>())).tracker_bbox_info as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(tracker_bbox_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsObjectMeta>())).confidence as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(confidence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsObjectMeta>())).tracker_confidence as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(tracker_confidence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsObjectMeta>())).rect_params as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(rect_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsObjectMeta>())).mask_params as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(mask_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsObjectMeta>())).text_params as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(text_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsObjectMeta>())).obj_label as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(obj_label)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsObjectMeta>())).classifier_meta_list as *const _ as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(classifier_meta_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsObjectMeta>())).obj_user_meta_list as *const _ as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(obj_user_meta_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsObjectMeta>())).misc_obj_info as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(misc_obj_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsObjectMeta>())).reserved as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsObjectMeta),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds metadata for an object in the frame."]
pub type NvDsObjectMeta = _NvDsObjectMeta;
#[doc = " Holds classifier metadata for an object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsClassifierMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the number of outputs/labels produced by the classifier."]
    pub num_labels: guint,
    #[doc = " Holds a unique component ID for the classifier metadata."]
    pub unique_component_id: gint,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsLabelInfo."]
    pub label_info_list: *mut NvDsLabelInfoList,
    #[doc = " Holds the type of the classifier."]
    pub classifier_type: *const gchar,
}
#[test]
fn bindgen_test_layout__NvDsClassifierMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsClassifierMeta>(),
        64usize,
        concat!("Size of: ", stringify!(_NvDsClassifierMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsClassifierMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsClassifierMeta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsClassifierMeta>())).base_meta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsClassifierMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsClassifierMeta>())).num_labels as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsClassifierMeta),
            "::",
            stringify!(num_labels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsClassifierMeta>())).unique_component_id as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsClassifierMeta),
            "::",
            stringify!(unique_component_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsClassifierMeta>())).label_info_list as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsClassifierMeta),
            "::",
            stringify!(label_info_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsClassifierMeta>())).classifier_type as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsClassifierMeta),
            "::",
            stringify!(classifier_type)
        )
    );
}
#[doc = " Holds classifier metadata for an object."]
pub type NvDsClassifierMeta = _NvDsClassifierMeta;
#[doc = " Holds label metadata for the classifier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsLabelInfo {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the number of classes of the given label."]
    pub num_classes: guint,
    #[doc = " Holds an string describing the label of the classified object."]
    pub result_label: [gchar; 128usize],
    #[doc = " Holds a pointer to the result label if its length exceeds MAX_LABEL_SIZE bytes."]
    pub pResult_label: *mut gchar,
    #[doc = " Holds the class UD of the best result."]
    pub result_class_id: guint,
    #[doc = " Holds the label ID in case there are multiple label classifiers."]
    pub label_id: guint,
    #[doc = " Holds the probability of best result."]
    pub result_prob: gfloat,
}
#[test]
fn bindgen_test_layout__NvDsLabelInfo() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsLabelInfo>(),
        200usize,
        concat!("Size of: ", stringify!(_NvDsLabelInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsLabelInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsLabelInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsLabelInfo>())).base_meta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsLabelInfo>())).num_classes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(num_classes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsLabelInfo>())).result_label as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(result_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsLabelInfo>())).pResult_label as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(pResult_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsLabelInfo>())).result_class_id as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(result_class_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsLabelInfo>())).label_id as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(label_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsLabelInfo>())).result_prob as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsLabelInfo),
            "::",
            stringify!(result_prob)
        )
    );
}
#[doc = " Holds label metadata for the classifier."]
pub type NvDsLabelInfo = _NvDsLabelInfo;
#[doc = " Holds display metadata that the user can specify in the frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsDisplayMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the number of rectangles described."]
    pub num_rects: guint,
    #[doc = " Holds the number of labels (strings) described."]
    pub num_labels: guint,
    #[doc = " Holds the number of lines described."]
    pub num_lines: guint,
    #[doc = " Holds the number of arrows described."]
    pub num_arrows: guint,
    #[doc = " Holds the number of circles described."]
    pub num_circles: guint,
    #[doc = " Holds an array of positional parameters for rectangles."]
    #[doc = "Used to overlay borders or semi-transparent rectangles,"]
    #[doc = "as required by the application. @see NvOSD_RectParams."]
    pub rect_params: [NvOSD_RectParams; 16usize],
    #[doc = " Holds an array of text parameters for user-defined strings that can be"]
    #[doc = "overlayed using this structure. @see NvOSD_TextParams."]
    pub text_params: [NvOSD_TextParams; 16usize],
    #[doc = " Holds an array of line parameters that the user can use to draw polygons"]
    #[doc = "in the frame, e.g. to show a RoI in the frame. @see NvOSD_LineParams."]
    pub line_params: [NvOSD_LineParams; 16usize],
    #[doc = " Holds an array of arrow parameters that the user can use to draw arrows"]
    #[doc = "in the frame. @see NvOSD_ArrowParams"]
    pub arrow_params: [NvOSD_ArrowParams; 16usize],
    #[doc = " Holds an array of circle parameters that the user can use to draw circles"]
    #[doc = "in the frame. @see NvOSD_CircleParams"]
    pub circle_params: [NvOSD_CircleParams; 16usize],
    #[doc = " Holds an array of user-defined OSD metadata."]
    pub misc_osd_data: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout_NvDsDisplayMeta() {
    assert_eq!(
        ::std::mem::size_of::<NvDsDisplayMeta>(),
        6912usize,
        concat!("Size of: ", stringify!(NvDsDisplayMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsDisplayMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsDisplayMeta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).base_meta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).num_rects as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(num_rects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).num_labels as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(num_labels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).num_lines as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(num_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).num_arrows as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(num_arrows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).num_circles as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(num_circles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).rect_params as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(rect_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).text_params as *const _ as usize },
        1728usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(text_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).line_params as *const _ as usize },
        3392usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(line_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).arrow_params as *const _ as usize },
        4288usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(arrow_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).circle_params as *const _ as usize },
        5312usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(circle_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).misc_osd_data as *const _ as usize },
        6848usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(misc_osd_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsDisplayMeta>())).reserved as *const _ as usize },
        6880usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsDisplayMeta),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds user metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsUserMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds a pointer to user data to be attached."]
    #[doc = "See the deepstream-user-metadata-test example for usage."]
    pub user_meta_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__NvDsUserMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsUserMeta>(),
        48usize,
        concat!("Size of: ", stringify!(_NvDsUserMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsUserMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsUserMeta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsUserMeta>())).base_meta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsUserMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsUserMeta>())).user_meta_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsUserMeta),
            "::",
            stringify!(user_meta_data)
        )
    );
}
#[doc = " Holds user metadata."]
pub type NvDsUserMeta = _NvDsUserMeta;
extern "C" {
    #[doc = " Acquires a lock before updating metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the NvDsBatchMeta structure"]
    #[doc = "                          to be locked."]
    pub fn nvds_acquire_meta_lock(batch_meta: *mut NvDsBatchMeta);
}
extern "C" {
    #[doc = " Releases the lock after updating metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to NvDsBatchMeta structure to be unlocked."]
    pub fn nvds_release_meta_lock(batch_meta: *mut NvDsBatchMeta);
}
extern "C" {
    #[doc = " Creates a batch metadata structure for a batch of specified size."]
    #[doc = ""]
    #[doc = " @param[in] max_batch_size    The maximum number of frames in the batch."]
    #[doc = " @ return  A pointer to the created structure."]
    pub fn nvds_create_batch_meta(max_batch_size: guint) -> *mut NvDsBatchMeta;
}
extern "C" {
    #[doc = " Destroys a batch metadata structure."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to batch metadata structure"]
    #[doc = "                          to be destroyed."]
    #[doc = " @returns  True if the object was successfully destroyed, or false otherwise."]
    pub fn nvds_destroy_batch_meta(batch_meta: *mut NvDsBatchMeta) -> gboolean;
}
extern "C" {
    #[doc = " \\brief  Acquires a frame meta from a batch's frame meta pool."]
    #[doc = ""]
    #[doc = " You must acquire a frame meta before you can fill it with frame metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to batch meta from which to acquire"]
    #[doc = "                          a frame meta."]
    #[doc = ""]
    #[doc = " @return  A pointer to the acquired frame meta."]
    pub fn nvds_acquire_frame_meta_from_pool(batch_meta: *mut NvDsBatchMeta) -> *mut NvDsFrameMeta;
}
extern "C" {
    #[doc = " Adds a frame meta to a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the NvDsBatchMeta to which"]
    #[doc = "                          @a frame_meta is to be added."]
    #[doc = " @param[in] frame_meta    A pointer to a frame meta to be added to"]
    #[doc = "                          @a batch_meta."]
    pub fn nvds_add_frame_meta_to_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " Removes a frame meta from a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which @a frame_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta to be removed from"]
    #[doc = "                          @a batch_meta."]
    pub fn nvds_remove_frame_meta_from_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " @brief  Acquires an object meta from a batch meta's object meta pool."]
    #[doc = ""]
    #[doc = " You must acquire an object meta before you can fill it with object metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which to acquire"]
    #[doc = "                          an object meta."]
    #[doc = ""]
    #[doc = " @return  A pointer to the acquired object meta."]
    pub fn nvds_acquire_obj_meta_from_pool(batch_meta: *mut NvDsBatchMeta) -> *mut NvDsObjectMeta;
}
extern "C" {
    #[doc = " @brief  Adds an object meta to a frame meta."]
    #[doc = ""]
    #[doc = " You must acquire the object meta with nvds_acquire_object_meta_from_pool()"]
    #[doc = " and fill it with metadata before you add to to the frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta to which @a obj_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] obj_meta      A pointer to an object meta to be added to @a frame_meta."]
    #[doc = " @param[in] obj_parent    A pointer to the this object meta's parent object meta."]
    #[doc = "                          This pointer is stored in @a obj_meta->parent."]
    pub fn nvds_add_obj_meta_to_frame(
        frame_meta: *mut NvDsFrameMeta,
        obj_meta: *mut NvDsObjectMeta,
        obj_parent: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " Removes an object meta from the frame meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to frame meta from which @a obj_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] obj_meta      A pointer to the object meta to be removed from"]
    #[doc = "                          @a frame_meta."]
    pub fn nvds_remove_obj_meta_from_frame(
        frame_meta: *mut NvDsFrameMeta,
        obj_meta: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " @brief  Acquires a classifier meta from a batch meta's classifier meta pool."]
    #[doc = ""]
    #[doc = " You must acquire a classifier meta from the classifier meta pool before you"]
    #[doc = " can fill it with classifier metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which to acquire"]
    #[doc = "                          a classifier meta."]
    #[doc = ""]
    #[doc = " @return  The classifier meta acquired from the batch meta's"]
    #[doc = "  classifier meta pool."]
    pub fn nvds_acquire_classifier_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsClassifierMeta;
}
extern "C" {
    #[doc = " @brief  Adds a classifier meta to the appropriate roi meta."]
    #[doc = ""]
    #[doc = " You must acquire a classifier meta with"]
    #[doc = " nvds_acquire_classifier_meta_from_pool() and fill it with"]
    #[doc = " classifier metadata before you add it to the roi metadata."]
    #[doc = ""]
    #[doc = " @param[in] roi_meta          A pointer to the roi meta to which"]
    #[doc = "                              @a classifier_meta is to be added."]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta to be added"]
    #[doc = "                              to @a roi_meta."]
    pub fn nvds_add_classifier_meta_to_roi(
        roi_meta: *mut NvDsRoiMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Removes a classifier meta from the roi meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] roi_meta          A pointer to the roi meta from which"]
    #[doc = "                              @a classifier_meta is to be removed."]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta to be removed"]
    #[doc = "                              from @a roi_meta."]
    pub fn nvds_remove_classifier_meta_from_roi(
        roi_meta: *mut NvDsRoiMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " @brief  Adds a classifier meta to the appropriate object meta."]
    #[doc = ""]
    #[doc = " You must acquire a classifier meta with"]
    #[doc = " nvds_acquire_classifier_meta_from_pool() and fill it with"]
    #[doc = " classifier metadata before you add it to the object metadata."]
    #[doc = ""]
    #[doc = " @param[in] obj_meta          A pointer to the object meta to which"]
    #[doc = "                              @a classifier_meta is to be added."]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta to be added"]
    #[doc = "                              to @a obj_meta."]
    pub fn nvds_add_classifier_meta_to_object(
        obj_meta: *mut NvDsObjectMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Removes a classifier meta from the object meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] obj_meta          A pointer to the object meta from which"]
    #[doc = "                              @a classifier_meta is to be removed."]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta to be removed"]
    #[doc = "                              from @a obj_meta."]
    pub fn nvds_remove_classifier_meta_from_obj(
        obj_meta: *mut NvDsObjectMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " @brief  Acquires a display meta from a batch meta's display meta pool."]
    #[doc = ""]
    #[doc = " You must acquire a display meta before you can fill it with display metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which to acquire"]
    #[doc = "                          a display meta."]
    #[doc = ""]
    #[doc = " @return  The display meta acquired from the batch meta's display meta pool."]
    pub fn nvds_acquire_display_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsDisplayMeta;
}
extern "C" {
    #[doc = " @brief  Adds a display meta to the appropriate frame meta."]
    #[doc = ""]
    #[doc = " You must acquire a display meta with nvds_)acquire_display_meta_from_pool()"]
    #[doc = " and fill it with display metadata before you can add it to the frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to frame meta to which @a display_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] display_meta  A pointer to the display meta to be added to"]
    #[doc = "                          @a frame_meta."]
    pub fn nvds_add_display_meta_to_frame(
        frame_meta: *mut NvDsFrameMeta,
        display_meta: *mut NvDsDisplayMeta,
    );
}
extern "C" {
    #[doc = " Removes a display meta from the frame meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta from which"]
    #[doc = "                          @a display_meta is to be removed."]
    #[doc = " @param[in] display_meta  A pointer to the display meta to be removed from"]
    #[doc = "                          @a frame_meta."]
    pub fn nvds_remove_display_meta_from_frame(
        frame_meta: *mut NvDsFrameMeta,
        display_meta: *mut NvDsDisplayMeta,
    );
}
extern "C" {
    #[doc = " @brief  Acquires a label info meta from a batch meta's label info meta pool."]
    #[doc = ""]
    #[doc = " You must acquire a label info meta before you can fill it and add it to a"]
    #[doc = " classifier meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which to acquire"]
    #[doc = "                          a label info meta."]
    #[doc = ""]
    #[doc = " @return  The label info meta acquired from the batch meta's"]
    #[doc = "  label info meta pool."]
    pub fn nvds_acquire_label_info_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsLabelInfo;
}
extern "C" {
    #[doc = " Adds a label info meta to a classifier meta."]
    #[doc = ""]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta to which"]
    #[doc = "                              @a label_info_meta is to be added."]
    #[doc = " @param[in] label_info_meta   A pointer to the label info meta to be added"]
    #[doc = "                              to @a classifier_meta."]
    pub fn nvds_add_label_info_meta_to_classifier(
        classifier_meta: *mut NvDsClassifierMeta,
        label_info_meta: *mut NvDsLabelInfo,
    );
}
extern "C" {
    #[doc = " Removes a label info meta from the classifier meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta from which"]
    #[doc = "                              @a label_info_meta is to be removed."]
    #[doc = " @param[in] label_info_meta   A pointer to the label info meta to be removed"]
    #[doc = "                              from @a classifier_meta."]
    pub fn nvds_remove_label_info_meta_from_classifier(
        classifier_meta: *mut NvDsClassifierMeta,
        label_info_meta: *mut NvDsLabelInfo,
    );
}
extern "C" {
    #[doc = " Add a user meta to a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to batch meta to which @a user_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] user_meta     A pointer to a user meta to be added to"]
    #[doc = "                          @a batch_meta."]
    pub fn nvds_add_user_meta_to_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Add a user meta to a frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta to which @a user_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] user_meta     A pointer to a user meta to be added to"]
    #[doc = "                          @a frame_meta."]
    pub fn nvds_add_user_meta_to_frame(
        frame_meta: *mut NvDsFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Add a user meta user to an roi meta."]
    #[doc = ""]
    #[doc = " @param[in] roi_meta      A pointer to the roi meta to which @a user_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] user_meta     A pointer to the user meta to be added to"]
    #[doc = "                          @a roi_meta."]
    pub fn nvds_add_user_meta_to_roi(roi_meta: *mut NvDsRoiMeta, user_meta: *mut NvDsUserMeta);
}
extern "C" {
    #[doc = " Add a user meta user to an object meta."]
    #[doc = ""]
    #[doc = " @param[in] obj_meta      A pointer to the object meta to which @a user_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] user_meta     A pointer to the user meta to be added to"]
    #[doc = "                          @a obj_meta."]
    pub fn nvds_add_user_meta_to_obj(obj_meta: *mut NvDsObjectMeta, user_meta: *mut NvDsUserMeta);
}
extern "C" {
    #[doc = " @brief  Acquires a user meta from a batch meta's user meta pool."]
    #[doc = ""]
    #[doc = " You must acquire a user meta before you can fill it with user metdata and"]
    #[doc = " add it to a batch, frame, or object meta (call nvds_add_user_data_to_batch(),"]
    #[doc = "  nvds_add_user_data_to_frame(), or nvds_add_user_data_to_obj())."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which to acquire"]
    #[doc = "                          a user meta."]
    pub fn nvds_acquire_user_meta_from_pool(batch_meta: *mut NvDsBatchMeta) -> *mut NvDsUserMeta;
}
extern "C" {
    #[doc = " Removes a user meta from a batch meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which @a user_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] user_meta     A pointer to the user meta to be removed from"]
    #[doc = "                          @a batch_meta."]
    #[doc = ""]
    #[doc = " returns acquired @ref NvDsUserMeta pointer from user meta pool"]
    pub fn nvds_remove_user_meta_from_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Removes a user meta from a frame meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta from which @a user_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] user_meta     A pointer to the user meta to be removed from"]
    #[doc = "                          @a frame_meta."]
    pub fn nvds_remove_user_meta_from_frame(
        frame_meta: *mut NvDsFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Removes a user meta from an roi meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] roi_meta      A pointer to the roi meta from which @a user_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] user_meta     A pointer to the user to be removed from"]
    #[doc = "                          @a roi_meta."]
    pub fn nvds_remove_user_meta_from_roi(obj_meta: *mut NvDsRoiMeta, user_meta: *mut NvDsUserMeta);
}
extern "C" {
    #[doc = " Removes a user meta from an object meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] obj_meta      A pointer to the object meta from which @a user_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] user_meta     A pointer to the user to be removed from"]
    #[doc = "                          @a obj_meta."]
    pub fn nvds_remove_user_meta_from_object(
        obj_meta: *mut NvDsObjectMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " A debugging function; prints current metadata information available after"]
    #[doc = " inference. This function should be called after inference."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to a batch meta from which to"]
    #[doc = "                          print information."]
    #[doc = " @return"]
    pub fn nvds_get_current_metadata_info(batch_meta: *mut NvDsBatchMeta) -> gboolean;
}
extern "C" {
    #[doc = " @brief  Copies or transforms meta data from one buffer to another."]
    #[doc = ""]
    #[doc = " @param[in] data      A pointer to a batch meta (of type @ref NvDsBatchMeta),"]
    #[doc = "                      cast to @c gpointer."]
    #[doc = " @param[in] user_data Currently not in use and should be set to NULL."]
    #[doc = ""]
    #[doc = " @return A pointer to a metadata structure, to be cast to type NvDsBatchMeta."]
    pub fn nvds_batch_meta_copy_func(data: gpointer, user_data: gpointer) -> gpointer;
}
extern "C" {
    #[doc = " Releases metadata from a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] data      A pointer to a batch meta (type @ref NvDsBatchMeta),"]
    #[doc = "                      cast to @c gpointer."]
    #[doc = " @param[in] user_data Currently not in use and should be set to NULL."]
    pub fn nvds_batch_meta_release_func(data: gpointer, user_data: gpointer);
}
extern "C" {
    #[doc = " Returns a pointer to a specified frame meta in the frame meta list."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta_list   A pointer to a list of pointers to frame metas."]
    #[doc = " @param[in] index             The index of the frame meta to be returned."]
    #[doc = ""]
    #[doc = " @return  A pointer to the @a index'th frame meta in the frame meta list."]
    pub fn nvds_get_nth_frame_meta(
        frame_meta_list: *mut NvDsFrameMetaList,
        index: guint,
    ) -> *mut NvDsFrameMeta;
}
extern "C" {
    #[doc = " Removes all of the frame metadata attached to a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch whose frame meta list"]
    #[doc = "                          is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the frame meta list to be cleared."]
    pub fn nvds_clear_frame_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsFrameMetaList,
    );
}
extern "C" {
    #[doc = " Removes all the object metadata attached to a frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta whose object meta list"]
    #[doc = "                          is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the object meta list to be cleared."]
    pub fn nvds_clear_obj_meta_list(
        frame_meta: *mut NvDsFrameMeta,
        meta_list: *mut NvDsObjectMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the classifier metadata attached to an object meta."]
    #[doc = ""]
    #[doc = " @param[in] obj_meta A pointer to @ref NvDsObjectMeta from which @a"]
    #[doc = "            NvDsClassifierMetaList needs to be cleared"]
    #[doc = " @param[in] meta_list A pointer to @ref NvDsClassifierMetaList which needs to"]
    #[doc = "            be cleared"]
    pub fn nvds_clear_classifier_meta_list(
        obj_meta: *mut NvDsObjectMeta,
        meta_list: *mut NvDsClassifierMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the label info metadata attached to a classifier meta."]
    #[doc = ""]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta whose"]
    #[doc = "                              label info meta list is to be cleared."]
    #[doc = " @param[in] meta_list         A pointer to the label info meta list to be"]
    #[doc = "                              cleared."]
    pub fn nvds_clear_label_info_meta_list(
        classifier_meta: *mut NvDsClassifierMeta,
        meta_list: *mut NvDsLabelInfoList,
    );
}
extern "C" {
    #[doc = " Removes all of the display metadata attached to a frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta whose display meta list"]
    #[doc = "                          is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the display meta list to be cleared."]
    pub fn nvds_clear_display_meta_list(
        frame_meta: *mut NvDsFrameMeta,
        meta_list: *mut NvDisplayMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to the batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta whose"]
    #[doc = "                          user meta list is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the user meta list to be"]
    #[doc = "            cleared"]
    pub fn nvds_clear_batch_user_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to the frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta whose"]
    #[doc = "                          user meta list is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the user meta list to be cleared."]
    pub fn nvds_clear_frame_user_meta_list(
        frame_meta: *mut NvDsFrameMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to an object meta."]
    #[doc = ""]
    #[doc = " @param[in] object_meta   A pointer to the object meta whose"]
    #[doc = "                          user meta list is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the user meta list to be cleared."]
    pub fn nvds_clear_obj_user_meta_list(
        object_meta: *mut NvDsObjectMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the metadata elements attached to a metadata list."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to a batch meta."]
    #[doc = " @param[in] meta_list     A pointer to meta list to be cleared."]
    #[doc = " @param[in] meta_pool     A pointer to the meta pool that contains"]
    #[doc = "                          @a meta_list."]
    #[doc = " @return  A pointer to the updated meta list."]
    pub fn nvds_clear_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsMetaList,
        meta_pool: *mut NvDsMetaPool,
    ) -> *mut NvDsMetaList;
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a frame meta to another frame meta."]
    #[doc = ""]
    #[doc = " @param[in] src_frame_meta    A pointer to the source frame meta."]
    #[doc = " @param[in] dst_frame_meta    A pointer to the destination frame meta."]
    pub fn nvds_copy_frame_meta(
        src_frame_meta: *mut NvDsFrameMeta,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of an object meta to another object meta."]
    #[doc = ""]
    #[doc = " @param[in] src_object_meta   A pointer to the source object meta."]
    #[doc = " @param[in] dst_object_meta   A pointer to the destination object meta."]
    pub fn nvds_copy_obj_meta(
        src_object_meta: *mut NvDsObjectMeta,
        dst_object_meta: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a classifier meta to another classifier meta."]
    #[doc = ""]
    #[doc = " @param[in] src_classifier_meta   A pointer to the source classifier meta."]
    #[doc = " @param[in] dst_classifier_meta A pointer to the destination classifier meta."]
    pub fn nvds_copy_classifier_meta(
        src_classifier_meta: *mut NvDsClassifierMeta,
        dst_classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a label info meta to another label info meta."]
    #[doc = ""]
    #[doc = " @param[in] src_label_info    A pointer to the source label info meta."]
    #[doc = " @param[in] dst_label_info    A pointer to the destination label info meta."]
    pub fn nvds_copy_label_info_meta(
        src_label_info: *mut NvDsLabelInfo,
        dst_label_info: *mut NvDsLabelInfo,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a display meta to another display meta."]
    #[doc = ""]
    #[doc = " @param[in] src_display_meta  A pointer to the source display meta."]
    #[doc = " @param[in] dst_display_meta  A pointer to destination display meta."]
    pub fn nvds_copy_display_meta(
        src_display_meta: *mut NvDsDisplayMeta,
        dst_display_meta: *mut NvDsDisplayMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a user meta list to the user meta list"]
    #[doc = " in a specified batch meta."]
    #[doc = ""]
    #[doc = " @param[in] src_user_meta_list    A pointer to the source user meta list."]
    #[doc = " @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_batch_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source user meta list to the user meta list"]
    #[doc = " in a specified frame meta."]
    #[doc = ""]
    #[doc = " @param[in] src_user_meta_list    A pointer to the source user meta list."]
    #[doc = " @param[in] dst_frame_meta        A pointer to the destination frame meta."]
    pub fn nvds_copy_frame_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source user meta list to the user meta list"]
    #[doc = " in a specified object meta."]
    #[doc = ""]
    #[doc = " @param[in] src_user_meta_list    A pointer to the source user meta list."]
    #[doc = " @param[in] dst_object_meta       A pointer to the destination object meta."]
    pub fn nvds_copy_obj_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_object_meta: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source display meta list to the"]
    #[doc = "  display meta list in a specified frame meta."]
    #[doc = ""]
    #[doc = " @param[in] src_display_meta_list A pointer to the source display meta list."]
    #[doc = " @param[in] dst_frame_meta        A pointer to the destination frame meta."]
    pub fn nvds_copy_display_meta_list(
        src_display_meta_list: *mut NvDisplayMetaList,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source frame meta list to the frame meta list"]
    #[doc = "  in a specified batch meta."]
    #[doc = ""]
    #[doc = " @param[in] src_frame_meta_list   A pointer to the source frame meta list."]
    #[doc = " @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_frame_meta_list(
        src_frame_meta_list: *mut NvDsFrameMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source object meta list to the"]
    #[doc = "  object meta list in a specified frame meta."]
    #[doc = ""]
    #[doc = " @param[in] src_obj_meta_list A pointer to the source object meta list."]
    #[doc = " @param[in] dst_frame_meta    A pointer to the destination frame meta."]
    pub fn nvds_copy_obj_meta_list(
        src_obj_meta_list: *mut NvDsObjectMetaList,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source classifier meta list to the"]
    #[doc = "  classifier meta list in a specified object meta."]
    #[doc = ""]
    #[doc = " @param[in] src_classifier_meta_list  A pointer to the source"]
    #[doc = "                                      classifier meta list."]
    #[doc = " @param[in] dst_object_meta           A pointer to the destination"]
    #[doc = "                                      object meta."]
    pub fn nvds_copy_classification_list(
        src_classifier_meta_list: *mut NvDsClassifierMetaList,
        dst_object_meta: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source label info meta list to the"]
    #[doc = "  label info meta list in a specified classifier meta."]
    #[doc = ""]
    #[doc = " @param[in] src_label_info_list   A pointer to the source"]
    #[doc = "                                  label info meta list."]
    #[doc = " @param[in] dst_classifier_meta   A pointer to the destination"]
    #[doc = "                                  classifier meta."]
    pub fn nvds_copy_label_info_list(
        src_label_info_list: *mut NvDsLabelInfoList,
        dst_classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Generates a unique user metadata type from a specified string describing"]
    #[doc = " user-specific metadata."]
    #[doc = ""]
    #[doc = " @param[in] meta_descriptor   A pointer to a string describing user-specific"]
    #[doc = "                              metadata. The string must be in the format"]
    #[doc = "                              @a ORG_NAME.COMPONENT_NAME.METADATA_DESCRIPTION,"]
    #[doc = "                              e.g. @c NVIDIA.NVINFER.TENSOR_METADATA."]
    pub fn nvds_get_user_meta_type(meta_descriptor: *mut gchar) -> NvDsMetaType;
}
pub const NvBufAudioFormat_NVBUF_AUDIO_INVALID_FORMAT: NvBufAudioFormat = 0;
pub const NvBufAudioFormat_NVBUF_AUDIO_S8: NvBufAudioFormat = 1;
pub const NvBufAudioFormat_NVBUF_AUDIO_U8: NvBufAudioFormat = 2;
pub const NvBufAudioFormat_NVBUF_AUDIO_S16LE: NvBufAudioFormat = 3;
pub const NvBufAudioFormat_NVBUF_AUDIO_S16BE: NvBufAudioFormat = 4;
pub const NvBufAudioFormat_NVBUF_AUDIO_U16LE: NvBufAudioFormat = 5;
pub const NvBufAudioFormat_NVBUF_AUDIO_U16BE: NvBufAudioFormat = 6;
pub const NvBufAudioFormat_NVBUF_AUDIO_S24_32LE: NvBufAudioFormat = 7;
pub const NvBufAudioFormat_NVBUF_AUDIO_S24_32BE: NvBufAudioFormat = 8;
pub const NvBufAudioFormat_NVBUF_AUDIO_U24_32LE: NvBufAudioFormat = 9;
pub const NvBufAudioFormat_NVBUF_AUDIO_U24_32BE: NvBufAudioFormat = 10;
pub const NvBufAudioFormat_NVBUF_AUDIO_S32LE: NvBufAudioFormat = 11;
pub const NvBufAudioFormat_NVBUF_AUDIO_S32BE: NvBufAudioFormat = 12;
pub const NvBufAudioFormat_NVBUF_AUDIO_U32LE: NvBufAudioFormat = 13;
pub const NvBufAudioFormat_NVBUF_AUDIO_U32BE: NvBufAudioFormat = 14;
pub const NvBufAudioFormat_NVBUF_AUDIO_S24LE: NvBufAudioFormat = 15;
pub const NvBufAudioFormat_NVBUF_AUDIO_S24BE: NvBufAudioFormat = 16;
pub const NvBufAudioFormat_NVBUF_AUDIO_U24LE: NvBufAudioFormat = 17;
pub const NvBufAudioFormat_NVBUF_AUDIO_U24BE: NvBufAudioFormat = 18;
pub const NvBufAudioFormat_NVBUF_AUDIO_S20LE: NvBufAudioFormat = 19;
pub const NvBufAudioFormat_NVBUF_AUDIO_S20BE: NvBufAudioFormat = 20;
pub const NvBufAudioFormat_NVBUF_AUDIO_U20LE: NvBufAudioFormat = 21;
pub const NvBufAudioFormat_NVBUF_AUDIO_U20BE: NvBufAudioFormat = 22;
pub const NvBufAudioFormat_NVBUF_AUDIO_S18LE: NvBufAudioFormat = 23;
pub const NvBufAudioFormat_NVBUF_AUDIO_S18BE: NvBufAudioFormat = 24;
pub const NvBufAudioFormat_NVBUF_AUDIO_U18LE: NvBufAudioFormat = 25;
pub const NvBufAudioFormat_NVBUF_AUDIO_U18BE: NvBufAudioFormat = 26;
pub const NvBufAudioFormat_NVBUF_AUDIO_F32LE: NvBufAudioFormat = 27;
pub const NvBufAudioFormat_NVBUF_AUDIO_F32BE: NvBufAudioFormat = 28;
pub const NvBufAudioFormat_NVBUF_AUDIO_F64LE: NvBufAudioFormat = 29;
pub const NvBufAudioFormat_NVBUF_AUDIO_F64BE: NvBufAudioFormat = 30;
#[doc = " Specifies audio formats"]
pub type NvBufAudioFormat = ::std::os::raw::c_uint;
pub const NvBufAudioLayout_NVBUF_AUDIO_INVALID_LAYOUT: NvBufAudioLayout = 0;
#[doc = "< audio sample from each channel shall be interleaved LRLRLRLR"]
pub const NvBufAudioLayout_NVBUF_AUDIO_INTERLEAVED: NvBufAudioLayout = 1;
#[doc = "< audio sample from each channel shall be interleaved ; LLLLLLLLRRRRRRRR"]
pub const NvBufAudioLayout_NVBUF_AUDIO_NON_INTERLEAVED: NvBufAudioLayout = 2;
#[doc = " Specifies audio data layout in memory"]
pub type NvBufAudioLayout = ::std::os::raw::c_uint;
#[doc = " Holds metadata for a audio frame in a batch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsAudioFrameMeta {
    #[doc = " Holds the base metadata for the frame."]
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the pad or port index of the Gst-streammux plugin for the frame"]
    #[doc = "in the batch."]
    pub pad_index: guint,
    #[doc = " Holds the location of the frame in the batch."]
    pub batch_id: guint,
    #[doc = " Holds the current frame number of the source."]
    pub frame_num: gint,
    #[doc = " Holds the presentation timestamp (PTS) of the frame."]
    pub buf_pts: guint64,
    #[doc = " Holds the ntp timestamp."]
    pub ntp_timestamp: guint64,
    #[doc = " Holds the source IDof the frame in the batch, e.g. the camera ID."]
    #[doc = "It need not be in sequential order."]
    pub source_id: guint,
    #[doc = " Holds the number of samples in the frame"]
    pub num_samples_per_frame: gint,
    pub sample_rate: guint,
    pub num_channels: guint,
    pub format: NvBufAudioFormat,
    pub layout: NvBufAudioLayout,
    #[doc = " Holds a Boolean indicating whether inference is performed on the frame."]
    pub bInferDone: gboolean,
    #[doc = " Holds the index of the last object class inferred by the primary"]
    #[doc = "detector/classifier."]
    pub class_id: gint,
    #[doc = " Hold confidence for last event detected (last NvDsClassifierMeta)"]
    pub confidence: gfloat,
    #[doc = " Holds a string describing the class of the detected event."]
    pub class_label: [gchar; 128usize],
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsClassifierMeta"]
    #[doc = "in use for the frame."]
    pub classifier_meta_list: *mut NvDsClassifierMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta"]
    #[doc = "in use for the frame."]
    pub frame_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds additional user-defined frame information."]
    pub misc_frame_info: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout__NvDsAudioFrameMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsAudioFrameMeta>(),
        320usize,
        concat!("Size of: ", stringify!(_NvDsAudioFrameMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsAudioFrameMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsAudioFrameMeta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).base_meta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(base_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).pad_index as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(pad_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).batch_id as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(batch_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).frame_num as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(frame_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).buf_pts as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(buf_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).ntp_timestamp as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(ntp_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).source_id as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).num_samples_per_frame as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(num_samples_per_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).sample_rate as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).num_channels as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(num_channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).format as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).layout as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).bInferDone as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(bInferDone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).class_id as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(class_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).confidence as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(confidence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).class_label as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(class_label)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).classifier_meta_list as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(classifier_meta_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).frame_user_meta_list as *const _
                as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(frame_user_meta_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).misc_frame_info as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(misc_frame_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsAudioFrameMeta>())).reserved as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsAudioFrameMeta),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Holds metadata for a audio frame in a batch."]
pub type NvDsAudioFrameMeta = _NvDsAudioFrameMeta;
extern "C" {
    #[doc = " Creates a batch metadata structure for a audio batch of specified size."]
    #[doc = ""]
    #[doc = " @param[in] max_batch_size    The maximum number of frames in the batch."]
    #[doc = " @ return  A pointer to the created structure."]
    pub fn nvds_create_audio_batch_meta(max_batch_size: guint) -> *mut NvDsBatchMeta;
}
extern "C" {
    #[doc = " Destroys a batch metadata structure."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to audio batch metadata structure"]
    #[doc = "                          to be destroyed."]
    #[doc = " @returns  True if the object was successfully destroyed, or false otherwise."]
    pub fn nvds_destroy_audio_batch_meta(batch_meta: *mut NvDsBatchMeta) -> gboolean;
}
extern "C" {
    #[doc = " \\brief  Acquires a audio frame meta from a batch's audio frame meta pool."]
    #[doc = ""]
    #[doc = " You must acquire a audio frame meta before you can fill it with audio frame metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to batch meta from which to acquire"]
    #[doc = "                          a audio frame meta."]
    #[doc = ""]
    #[doc = " @return  A pointer to the acquired audio frame meta."]
    pub fn nvds_acquire_audio_frame_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsAudioFrameMeta;
}
extern "C" {
    #[doc = " Adds a audio frame meta to a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the NvDsBatchMeta to which"]
    #[doc = "                          @a frame_meta is to be added."]
    #[doc = " @param[in] frame_meta    A pointer to a frame meta to be added to"]
    #[doc = "                          @a batch_meta."]
    pub fn nvds_add_audio_frame_meta_to_audio_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsAudioFrameMeta,
    );
}
extern "C" {
    #[doc = " Removes a audio frame meta from a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which @a frame_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta to be removed from"]
    #[doc = "                          @a batch_meta."]
    pub fn nvds_remove_audio_frame_meta_from_audio_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsAudioFrameMeta,
    );
}
extern "C" {
    #[doc = " @brief  Adds a classifier meta the audio frame meta."]
    #[doc = ""]
    #[doc = " You must acquire a classifier meta with"]
    #[doc = " nvds_acquire_classifier_meta_from_pool() and fill it with"]
    #[doc = " classifier metadata before you add it to the audio frame metadata."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta        A pointer to the frame meta to which"]
    #[doc = "                              @a classifier_meta is to be added."]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta to be added"]
    #[doc = "                              to @a obj_meta."]
    pub fn nvds_add_classifier_meta_to_audio_frame(
        frame_meta: *mut NvDsAudioFrameMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Removes a classifier meta from the audio frame meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta          A pointer to the frame meta from which"]
    #[doc = "                              @a classifier_meta is to be removed."]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta to be removed"]
    #[doc = "                              from @a frame_meta."]
    pub fn nvds_remove_classifier_meta_from_audio_frame(
        frame_meta: *mut NvDsAudioFrameMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Add a user meta to a audio batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to batch meta to which @a user_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] user_meta     A pointer to a user meta to be added to"]
    #[doc = "                          @a batch_meta."]
    pub fn nvds_add_user_meta_to_audio_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Add a user meta to a audio frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta to which @a user_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] user_meta     A pointer to a user meta to be added to"]
    #[doc = "                          @a frame_meta."]
    pub fn nvds_add_user_meta_to_audio_frame(
        frame_meta: *mut NvDsAudioFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Removes a user meta from a audio batch meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the audio batch meta from which @a user_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] user_meta     A pointer to the user meta to be removed from"]
    #[doc = "                          @a batch_meta."]
    #[doc = ""]
    #[doc = " returns acquired @ref NvDsUserMeta pointer from user meta pool"]
    pub fn nvds_remove_user_meta_from_audio_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Removes a user meta from a audio frame meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta from which @a user_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] user_meta     A pointer to the user meta to be removed from"]
    #[doc = "                          @a frame_meta."]
    pub fn nvds_remove_user_meta_from_audio_frame(
        frame_meta: *mut NvDsAudioFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " @brief  Copies or transforms meta data from one buffer to another."]
    #[doc = ""]
    #[doc = " @param[in] data      A pointer to a batch meta (of type @ref NvDsBatchMeta),"]
    #[doc = "                      cast to @c gpointer."]
    #[doc = " @param[in] user_data Currently not in use and should be set to NULL."]
    #[doc = ""]
    #[doc = " @return A pointer to a metadata structure, to be cast to type NvDsBatchMeta."]
    pub fn nvds_audio_batch_meta_copy_func(data: gpointer, user_data: gpointer) -> gpointer;
}
extern "C" {
    #[doc = " Releases metadata from a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] data      A pointer to a batch meta (type @ref NvDsBatchMeta),"]
    #[doc = "                      cast to @c gpointer."]
    #[doc = " @param[in] user_data Currently not in use and should be set to NULL."]
    pub fn nvds_audio_batch_meta_release_func(data: gpointer, user_data: gpointer);
}
extern "C" {
    #[doc = " Returns a pointer to a specified frame meta in the frame meta list."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta_list   A pointer to a list of pointers to frame metas."]
    #[doc = " @param[in] index             The index of the frame meta to be returned."]
    #[doc = ""]
    #[doc = " @return  A pointer to the @a index'th frame meta in the frame meta list."]
    pub fn nvds_get_nth_audio_frame_meta(
        frame_meta_list: *mut NvDsFrameMetaList,
        index: guint,
    ) -> *mut NvDsAudioFrameMeta;
}
extern "C" {
    #[doc = " Removes all of the frame metadata attached to a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch whose frame meta list"]
    #[doc = "                          is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the frame meta list to be cleared."]
    pub fn nvds_clear_audio_frame_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsFrameMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the classifier metadata attached to an audio frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta A pointer to @ref NvDsAudioFrameMeta from which @a"]
    #[doc = "            NvDsClassifierMetaList needs to be cleared"]
    #[doc = " @param[in] meta_list A pointer to @ref NvDsClassifierMetaList which needs to"]
    #[doc = "            be cleared"]
    pub fn nvds_clear_audio_classifier_meta_list(
        frame_meta: *mut NvDsAudioFrameMeta,
        meta_list: *mut NvDsClassifierMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to the audio batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the audio batch meta whose"]
    #[doc = "                          user meta list is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the user meta list to be"]
    #[doc = "            cleared"]
    pub fn nvds_clear_audio_batch_user_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to the audio frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the audio frame meta whose"]
    #[doc = "                          user meta list is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the user meta list to be cleared."]
    pub fn nvds_clear_audio_frame_user_meta_list(
        frame_meta: *mut NvDsAudioFrameMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a user meta list to the user meta list"]
    #[doc = " in a specified audio batch meta."]
    #[doc = ""]
    #[doc = " @param[in] src_user_meta_list    A pointer to the source user meta list."]
    #[doc = " @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_audio_batch_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a frame meta to another frame meta."]
    #[doc = ""]
    #[doc = " @param[in] src_frame_meta    A pointer to the source frame meta."]
    #[doc = " @param[in] dst_frame_meta    A pointer to the destination frame meta."]
    pub fn nvds_copy_audio_frame_meta(
        src_frame_meta: *mut NvDsAudioFrameMeta,
        dst_frame_meta: *mut NvDsAudioFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source user meta list to the user meta list"]
    #[doc = " in a specified audio frame meta."]
    #[doc = ""]
    #[doc = " @param[in] src_user_meta_list    A pointer to the source user meta list."]
    #[doc = " @param[in] dst_frame_meta        A pointer to the destination audio frame meta."]
    pub fn nvds_copy_audio_frame_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_frame_meta: *mut NvDsAudioFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source frame meta list to the frame meta list"]
    #[doc = "  in a specified batch meta."]
    #[doc = ""]
    #[doc = " @param[in] src_frame_meta_list   A pointer to the source frame meta list."]
    #[doc = " @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_audio_frame_meta_list(
        src_frame_meta_list: *mut NvDsFrameMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source classifier meta list to the"]
    #[doc = "  classifier meta list in a specified object meta."]
    #[doc = ""]
    #[doc = " @param[in] src_classifier_meta_list  A pointer to the source"]
    #[doc = "                                      classifier meta list."]
    #[doc = " @param[in] dst_frame_meta           A pointer to the destination"]
    #[doc = "                                      audio frame meta."]
    pub fn nvds_copy_audio_classification_list(
        src_classifier_meta_list: *mut NvDsClassifierMetaList,
        dst_frame_meta: *mut NvDsAudioFrameMeta,
    );
}
#[doc = " Holds information about the latency of a given frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsFrameLatencyInfo {
    #[doc = " Holds the source ID of the component, e.g. the camera ID."]
    pub source_id: guint,
    #[doc = " Holds the current frame number for which latency is measured."]
    pub frame_num: guint,
    #[doc = " Holds the system timestamp of the buffer when it arrives"]
    #[doc = "at the input of the first component in the pipeline. By default,"]
    #[doc = "the decoder is considered to be the first component in the pipeline."]
    pub comp_in_timestamp: gdouble,
    #[doc = " Holds the latency of the frame in milliseconds."]
    pub latency: gdouble,
}
#[test]
fn bindgen_test_layout_NvDsFrameLatencyInfo() {
    assert_eq!(
        ::std::mem::size_of::<NvDsFrameLatencyInfo>(),
        24usize,
        concat!("Size of: ", stringify!(NvDsFrameLatencyInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsFrameLatencyInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsFrameLatencyInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsFrameLatencyInfo>())).source_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsFrameLatencyInfo),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsFrameLatencyInfo>())).frame_num as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsFrameLatencyInfo),
            "::",
            stringify!(frame_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NvDsFrameLatencyInfo>())).comp_in_timestamp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsFrameLatencyInfo),
            "::",
            stringify!(comp_in_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvDsFrameLatencyInfo>())).latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvDsFrameLatencyInfo),
            "::",
            stringify!(latency)
        )
    );
}
extern "C" {
    #[doc = " Sets the system timestamp when the Gst Buffer arrives as input at the"]
    #[doc = " component."]
    #[doc = ""]
    #[doc = " @param[in] buffer        A pointer to the arriving Gst Buffer."]
    #[doc = " @param[in] element_name  A pointer to the name of the component for which"]
    #[doc = "                          latency is to be measured."]
    #[doc = ""]
    #[doc = " @returns  A pointer to a @ref NvDsUserMeta structure which holds an"]
    #[doc = "          @ref NvDsMetaCompLatency as @a NvDsUserMeta.user_meta_data."]
    pub fn nvds_set_input_system_timestamp(
        buffer: *mut GstBuffer,
        element_name: *mut gchar,
    ) -> *mut NvDsUserMeta;
}
extern "C" {
    #[doc = " \\brief  Sets the system timestamp when a Gst Buffer that is pushed"]
    #[doc = "  to the downstream component."]
    #[doc = ""]
    #[doc = " This is a corresponding function to nvds_set_input_system_timestamp()."]
    #[doc = ""]
    #[doc = " @param[in] buffer        A pointer to a Gst Buffer to be pushed"]
    #[doc = "                          to the downstream component."]
    #[doc = " @param[in] element_name  A pointer to the name of the component for which"]
    #[doc = "                          latency is to be measured."]
    #[doc = ""]
    #[doc = " @returns  TRUE if the timestamp is attached successfully, or FALSE otherwise."]
    pub fn nvds_set_output_system_timestamp(
        buffer: *mut GstBuffer,
        element_name: *mut gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn nvds_add_sub_time(
        buffer: *mut GstBuffer,
        element_name: *mut gchar,
        name: *mut gchar,
        start_time: gdouble,
        end_time: gdouble,
    ) -> gboolean;
}
extern "C" {
    #[doc = " \\brief  Measures the latency of all frames present in the current batch."]
    #[doc = ""]
    #[doc = " The latency is computed from decoder input up to the point this API is called."]
    #[doc = " You can install the probe on either pad of the component and call"]
    #[doc = " this function to measure the latency."]
    #[doc = ""]
    #[doc = " @param[in]  buf          A pointer to a Gst Buffer to which"]
    #[doc = "                          @ref NvDsBatchMeta is attached as metadata."]
    #[doc = " @param[out] latency_info A pointer to an NvDsFrameLatencyInfo structure"]
    #[doc = "                          allocated for a batch of this size. The function"]
    #[doc = "                          fills it with information about all of the sources."]
    pub fn nvds_measure_buffer_latency(
        buf: *mut GstBuffer,
        latency_info: *mut NvDsFrameLatencyInfo,
    ) -> guint;
}
extern "C" {
    #[doc = " Indicates whether the environment variable"]
    #[doc = " @c NVDS_ENABLE_LATENCY_MEASUREMENT is exported."]
    #[doc = ""]
    #[doc = " @returns  True if the environment variable is exported, or false otherwise."]
    pub fn nvds_get_enable_latency_measurement() -> gboolean;
}
extern "C" {
    pub fn nvds_meta_api_get_type() -> GType;
}
extern "C" {
    pub fn nvds_meta_get_info() -> *const GstMetaInfo;
}
#[doc = " Holds DeepSteam metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsMeta {
    pub meta: GstMeta,
    #[doc = " Holds a pointer to metadata. Must be cast to another structure based"]
    #[doc = "on @a meta_type."]
    pub meta_data: gpointer,
    #[doc = " Holds a pointer to user-specific data ."]
    pub user_data: gpointer,
    #[doc = " Holds the type of metadata, one of values of enum @ref GstNvDsMetaType."]
    pub meta_type: gint,
    #[doc = " A callback to be called when @a meta_data is to be copied or transformed"]
    #[doc = "from one buffer to other. @a meta_data and @a user_data are passed"]
    #[doc = "as arguments."]
    pub copyfunc: NvDsMetaCopyFunc,
    #[doc = " A callback to be called when @a meta_data is to be destroyed."]
    #[doc = "@a meta_data and @a user_data are passed as arguments."]
    pub freefunc: NvDsMetaReleaseFunc,
    #[doc = " A callback to be called when @a meta_data is transformed into"]
    #[doc = " @a NvDsUserMeta."]
    #[doc = " This function must be provided by a GStreamer plugin that precedes"]
    #[doc = " @a Gst-nvstreammux in the DeepStream pipeline."]
    #[doc = " Gst-nvstreammux copies @a meta_data to"]
    #[doc = " user meta data at frame level inside @ref NvDsFrameMeta."]
    #[doc = " @a meta_data and @a user_data are passed as arguments."]
    #[doc = ""]
    #[doc = " To retrive the content of @a meta_data, iterate over"]
    #[doc = " @ref NvDsFrameMetaList. Then search for @a meta_type of @ref NvDsUserMeta"]
    #[doc = " which the user has attached. (See deepstream-gst-metadata-test source"]
    #[doc = " code for more details.)"]
    #[doc = ""]
    #[doc = " @a meta_data and @a user_data are passed as arguments."]
    pub gst_to_nvds_meta_transform_func: NvDsMetaCopyFunc,
    #[doc = " A callback to be called when @a meta_data transformed into"]
    #[doc = " @a NvDsUserMeta is to be destroyed."]
    #[doc = " This function must be provided by a GStreamer plugin that precedes"]
    #[doc = " @a Gst-nvstreammux in the DeepStream pipeline."]
    pub gst_to_nvds_meta_release_func: NvDsMetaReleaseFunc,
}
#[test]
fn bindgen_test_layout__NvDsMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsMeta>(),
        72usize,
        concat!("Size of: ", stringify!(_NvDsMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsMeta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMeta>())).meta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMeta>())).meta_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(meta_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMeta>())).user_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMeta>())).meta_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(meta_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMeta>())).copyfunc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(copyfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NvDsMeta>())).freefunc as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(freefunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsMeta>())).gst_to_nvds_meta_transform_func as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(gst_to_nvds_meta_transform_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NvDsMeta>())).gst_to_nvds_meta_release_func as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NvDsMeta),
            "::",
            stringify!(gst_to_nvds_meta_release_func)
        )
    );
}
#[doc = " Holds DeepSteam metadata."]
pub type NvDsMeta = _NvDsMeta;
extern "C" {
    #[doc = " Adds %GstMeta of type @ref NvDsMeta to the GstBuffer and sets the @a meta_data"]
    #[doc = " member of @ref NvDsMeta."]
    #[doc = ""]
    #[doc = " @param[in] buffer    A pointer to a %GstBuffer to which the function adds"]
    #[doc = "                      metadata."]
    #[doc = " @param[in] meta_data A pointer at which the function sets the @a meta_data"]
    #[doc = "                      member of @ref NvDsMeta."]
    #[doc = " @param[in] user_data A pointer to the user-specific data."]
    #[doc = " @param[in] copy_func The callback to be called when"]
    #[doc = "                      NvDsMeta is to be copied. The function is called with"]
    #[doc = "                      @a meta_data and @a user_data as parameters."]
    #[doc = " @param[in] release_func"]
    #[doc = "                      The callback to be called when"]
    #[doc = "                      NvDsMeta is to be destroyed. The function is called with"]
    #[doc = "                      @a meta_data and @a user_data as parameters."]
    #[doc = ""]
    #[doc = " @return  A pointer to the attached NvDsMeta structure if successful,"]
    #[doc = "  or NULL otherwise."]
    pub fn gst_buffer_add_nvds_meta(
        buffer: *mut GstBuffer,
        meta_data: gpointer,
        user_data: gpointer,
        copy_func: NvDsMetaCopyFunc,
        release_func: NvDsMetaReleaseFunc,
    ) -> *mut NvDsMeta;
}
extern "C" {
    #[doc = " Gets the @ref NvDsMeta last added to a GstBuffer."]
    #[doc = ""]
    #[doc = " @param[in] buffer    A pointer to the GstBuffer."]
    #[doc = ""]
    #[doc = " @return  A pointer to the last added NvDsMeta structure, or NULL if no"]
    #[doc = "          %NvDsMeta was attached."]
    pub fn gst_buffer_get_nvds_meta(buffer: *mut GstBuffer) -> *mut NvDsMeta;
}
extern "C" {
    #[doc = " Gets the @ref NvDsBatchMeta added to a GstBuffer."]
    #[doc = ""]
    #[doc = " @param[in] buffer    A pointer to the GstBuffer."]
    #[doc = ""]
    #[doc = " @return  A pointer to the NvDsBatchMeta structure, or NULL if no"]
    #[doc = "          NvDsMeta was attached."]
    pub fn gst_buffer_get_nvds_batch_meta(buffer: *mut GstBuffer) -> *mut NvDsBatchMeta;
}
